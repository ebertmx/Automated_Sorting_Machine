
RiskySortingMachine.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000048  00800200  00001a70  00001b04  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001a70  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000fa  00800248  00800248  00001b4c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001b4c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001b7c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001f8  00000000  00000000  00001bbc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002bed  00000000  00000000  00001db4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000011b9  00000000  00000000  000049a1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000017b7  00000000  00000000  00005b5a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000064c  00000000  00000000  00007314  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000a71  00000000  00000000  00007960  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000011cd  00000000  00000000  000083d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001b8  00000000  00000000  0000959e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	0c 94 5d 09 	jmp	0x12ba	; 0x12ba <__vector_1>
       8:	01 c7       	rjmp	.+3586   	; 0xe0c <__vector_2>
       a:	00 00       	nop
       c:	c8 c7       	rjmp	.+3984   	; 0xf9e <__vector_3>
       e:	00 00       	nop
      10:	0c 94 2a 09 	jmp	0x1254	; 0x1254 <__vector_4>
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	0c 94 cc 09 	jmp	0x1398	; 0x1398 <__vector_9>
      28:	0c 94 94 09 	jmp	0x1328	; 0x1328 <__vector_10>
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	79 c0       	rjmp	.+242    	; 0x124 <__bad_interrupt>
      32:	00 00       	nop
      34:	77 c0       	rjmp	.+238    	; 0x124 <__bad_interrupt>
      36:	00 00       	nop
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	6f c0       	rjmp	.+222    	; 0x124 <__bad_interrupt>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	67 c0       	rjmp	.+206    	; 0x124 <__bad_interrupt>
      56:	00 00       	nop
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	5f c0       	rjmp	.+190    	; 0x124 <__bad_interrupt>
      66:	00 00       	nop
      68:	5d c0       	rjmp	.+186    	; 0x124 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	0c 94 d5 08 	jmp	0x11aa	; 0x11aa <__vector_29>
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 a4 08 	jmp	0x1148	; 0x1148 <__vector_32>
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	49 c0       	rjmp	.+146    	; 0x124 <__bad_interrupt>
      92:	00 00       	nop
      94:	47 c0       	rjmp	.+142    	; 0x124 <__bad_interrupt>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3f c0       	rjmp	.+126    	; 0x124 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	85 c3       	rjmp	.+1802   	; 0x7b4 <__vector_42>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	37 c0       	rjmp	.+110    	; 0x124 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	5d c2       	rjmp	.+1210   	; 0x578 <__vector_47>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2b c0       	rjmp	.+86     	; 0x124 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	29 c0       	rjmp	.+82     	; 0x124 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	25 c0       	rjmp	.+74     	; 0x124 <__bad_interrupt>
      da:	00 00       	nop
      dc:	23 c0       	rjmp	.+70     	; 0x124 <__bad_interrupt>
      de:	00 00       	nop
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e0 e7       	ldi	r30, 0x70	; 112
      fc:	fa e1       	ldi	r31, 0x1A	; 26
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a8 34       	cpi	r26, 0x48	; 72
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	23 e0       	ldi	r18, 0x03	; 3
     110:	a8 e4       	ldi	r26, 0x48	; 72
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	a2 34       	cpi	r26, 0x42	; 66
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	c2 d5       	rcall	.+2948   	; 0xca4 <main>
     120:	0c 94 36 0d 	jmp	0x1a6c	; 0x1a6c <_exit>

00000124 <__bad_interrupt>:
     124:	5e c3       	rjmp	.+1724   	; 0x7e2 <__vector_default>

00000126 <CalcExitTime>:
	LCDWriteInt(TARGETFLAG,1);
	LCDWriteStringXY(0,1," ");
	LCDWriteString("D");
	LCDWriteInt(DECELFLAG,1);
	LCDWriteString(" S");
	LCDWriteInt(HOLDFLAG,1);
     126:	80 91 6b 02 	lds	r24, 0x026B	; 0x80026b <HOLDFLAG>
     12a:	81 11       	cpse	r24, r1
     12c:	b7 c0       	rjmp	.+366    	; 0x29c <CalcExitTime+0x176>
     12e:	80 91 11 02 	lds	r24, 0x0211	; 0x800211 <CurPosition>
     132:	e0 91 64 02 	lds	r30, 0x0264	; 0x800264 <countSort>
     136:	f0 e0       	ldi	r31, 0x00	; 0
     138:	e8 58       	subi	r30, 0x88	; 136
     13a:	fd 4f       	sbci	r31, 0xFD	; 253
     13c:	20 81       	ld	r18, Z
     13e:	90 e0       	ldi	r25, 0x00	; 0
     140:	82 1b       	sub	r24, r18
     142:	91 09       	sbc	r25, r1
     144:	9c 01       	movw	r18, r24
     146:	22 f4       	brpl	.+8      	; 0x150 <CalcExitTime+0x2a>
     148:	22 27       	eor	r18, r18
     14a:	33 27       	eor	r19, r19
     14c:	28 1b       	sub	r18, r24
     14e:	39 0b       	sbc	r19, r25
     150:	8e e0       	ldi	r24, 0x0E	; 14
     152:	82 1b       	sub	r24, r18
     154:	80 93 4d 02 	sts	0x024D, r24	; 0x80024d <Steps2Exit>
     158:	80 91 14 02 	lds	r24, 0x0214	; 0x800214 <Steps2Acc>
     15c:	90 91 78 02 	lds	r25, 0x0278	; 0x800278 <accSteps>
     160:	89 1b       	sub	r24, r25
     162:	80 93 4c 02 	sts	0x024C, r24	; 0x80024c <Steps2MIN>
     166:	40 91 13 02 	lds	r20, 0x0213	; 0x800213 <Dir>
     16a:	20 91 74 02 	lds	r18, 0x0274	; 0x800274 <CurError>
     16e:	30 91 75 02 	lds	r19, 0x0275	; 0x800275 <CurError+0x1>
     172:	42 03       	mulsu	r20, r18
     174:	c0 01       	movw	r24, r0
     176:	43 9f       	mul	r20, r19
     178:	90 0d       	add	r25, r0
     17a:	11 24       	eor	r1, r1
     17c:	18 16       	cp	r1, r24
     17e:	19 06       	cpc	r1, r25
     180:	44 f0       	brlt	.+16     	; 0x192 <CalcExitTime+0x6c>
     182:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <CurDelay>
     186:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <CurDelay+0x1>
     18a:	81 15       	cp	r24, r1
     18c:	9a 40       	sbci	r25, 0x0A	; 10
     18e:	08 f4       	brcc	.+2      	; 0x192 <CalcExitTime+0x6c>
     190:	41 c0       	rjmp	.+130    	; 0x214 <CalcExitTime+0xee>
     192:	90 91 4d 02 	lds	r25, 0x024D	; 0x80024d <Steps2Exit>
     196:	80 91 14 02 	lds	r24, 0x0214	; 0x800214 <Steps2Acc>
     19a:	98 17       	cp	r25, r24
     19c:	a0 f4       	brcc	.+40     	; 0x1c6 <CalcExitTime+0xa0>
     19e:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <CurDelay>
     1a2:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <CurDelay+0x1>
     1a6:	80 5f       	subi	r24, 0xF0	; 240
     1a8:	92 40       	sbci	r25, 0x02	; 2
     1aa:	96 95       	lsr	r25
     1ac:	87 95       	ror	r24
     1ae:	40 91 4d 02 	lds	r20, 0x024D	; 0x80024d <Steps2Exit>
     1b2:	48 9f       	mul	r20, r24
     1b4:	90 01       	movw	r18, r0
     1b6:	49 9f       	mul	r20, r25
     1b8:	30 0d       	add	r19, r0
     1ba:	11 24       	eor	r1, r1
     1bc:	30 93 53 02 	sts	0x0253, r19	; 0x800253 <exitTime+0x1>
     1c0:	20 93 52 02 	sts	0x0252, r18	; 0x800252 <exitTime>
     1c4:	5e c0       	rjmp	.+188    	; 0x282 <CalcExitTime+0x15c>
     1c6:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <CurDelay>
     1ca:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <CurDelay+0x1>
     1ce:	80 5f       	subi	r24, 0xF0	; 240
     1d0:	92 40       	sbci	r25, 0x02	; 2
     1d2:	96 95       	lsr	r25
     1d4:	87 95       	ror	r24
     1d6:	40 91 4c 02 	lds	r20, 0x024C	; 0x80024c <Steps2MIN>
     1da:	48 9f       	mul	r20, r24
     1dc:	90 01       	movw	r18, r0
     1de:	49 9f       	mul	r20, r25
     1e0:	30 0d       	add	r19, r0
     1e2:	11 24       	eor	r1, r1
     1e4:	80 91 4d 02 	lds	r24, 0x024D	; 0x80024d <Steps2Exit>
     1e8:	40 91 14 02 	lds	r20, 0x0214	; 0x800214 <Steps2Acc>
     1ec:	90 e0       	ldi	r25, 0x00	; 0
     1ee:	84 1b       	sub	r24, r20
     1f0:	91 09       	sbc	r25, r1
     1f2:	60 ef       	ldi	r22, 0xF0	; 240
     1f4:	72 e0       	ldi	r23, 0x02	; 2
     1f6:	86 9f       	mul	r24, r22
     1f8:	a0 01       	movw	r20, r0
     1fa:	87 9f       	mul	r24, r23
     1fc:	50 0d       	add	r21, r0
     1fe:	96 9f       	mul	r25, r22
     200:	50 0d       	add	r21, r0
     202:	11 24       	eor	r1, r1
     204:	ca 01       	movw	r24, r20
     206:	82 0f       	add	r24, r18
     208:	93 1f       	adc	r25, r19
     20a:	90 93 53 02 	sts	0x0253, r25	; 0x800253 <exitTime+0x1>
     20e:	80 93 52 02 	sts	0x0252, r24	; 0x800252 <exitTime>
     212:	37 c0       	rjmp	.+110    	; 0x282 <CalcExitTime+0x15c>
     214:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <CurDelay>
     218:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <CurDelay+0x1>
     21c:	20 e0       	ldi	r18, 0x00	; 0
     21e:	3a e0       	ldi	r19, 0x0A	; 10
     220:	28 1b       	sub	r18, r24
     222:	39 0b       	sbc	r19, r25
     224:	36 95       	lsr	r19
     226:	27 95       	ror	r18
     228:	40 91 14 02 	lds	r20, 0x0214	; 0x800214 <Steps2Acc>
     22c:	42 9f       	mul	r20, r18
     22e:	c0 01       	movw	r24, r0
     230:	43 9f       	mul	r20, r19
     232:	90 0d       	add	r25, r0
     234:	11 24       	eor	r1, r1
     236:	60 91 14 02 	lds	r22, 0x0214	; 0x800214 <Steps2Acc>
     23a:	48 e8       	ldi	r20, 0x88	; 136
     23c:	53 e0       	ldi	r21, 0x03	; 3
     23e:	64 9f       	mul	r22, r20
     240:	90 01       	movw	r18, r0
     242:	65 9f       	mul	r22, r21
     244:	30 0d       	add	r19, r0
     246:	11 24       	eor	r1, r1
     248:	82 0f       	add	r24, r18
     24a:	93 1f       	adc	r25, r19
     24c:	20 91 4d 02 	lds	r18, 0x024D	; 0x80024d <Steps2Exit>
     250:	40 91 14 02 	lds	r20, 0x0214	; 0x800214 <Steps2Acc>
     254:	30 91 4c 02 	lds	r19, 0x024C	; 0x80024c <Steps2MIN>
     258:	50 e0       	ldi	r21, 0x00	; 0
     25a:	43 1b       	sub	r20, r19
     25c:	51 09       	sbc	r21, r1
     25e:	30 e0       	ldi	r19, 0x00	; 0
     260:	24 1b       	sub	r18, r20
     262:	35 0b       	sbc	r19, r21
     264:	60 ef       	ldi	r22, 0xF0	; 240
     266:	72 e0       	ldi	r23, 0x02	; 2
     268:	26 9f       	mul	r18, r22
     26a:	a0 01       	movw	r20, r0
     26c:	27 9f       	mul	r18, r23
     26e:	50 0d       	add	r21, r0
     270:	36 9f       	mul	r19, r22
     272:	50 0d       	add	r21, r0
     274:	11 24       	eor	r1, r1
     276:	84 0f       	add	r24, r20
     278:	95 1f       	adc	r25, r21
     27a:	90 93 53 02 	sts	0x0253, r25	; 0x800253 <exitTime+0x1>
     27e:	80 93 52 02 	sts	0x0252, r24	; 0x800252 <exitTime>
     282:	20 91 52 02 	lds	r18, 0x0252	; 0x800252 <exitTime>
     286:	30 91 53 02 	lds	r19, 0x0253	; 0x800253 <exitTime+0x1>
     28a:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <dropTime>
     28e:	90 91 03 02 	lds	r25, 0x0203	; 0x800203 <dropTime+0x1>
     292:	28 17       	cp	r18, r24
     294:	39 07       	cpc	r19, r25
     296:	20 f4       	brcc	.+8      	; 0x2a0 <CalcExitTime+0x17a>
     298:	81 e0       	ldi	r24, 0x01	; 1
     29a:	08 95       	ret
     29c:	80 e0       	ldi	r24, 0x00	; 0
     29e:	08 95       	ret
     2a0:	80 e0       	ldi	r24, 0x00	; 0
     2a2:	08 95       	ret

000002a4 <CalcEnterTime>:
     2a4:	80 91 74 02 	lds	r24, 0x0274	; 0x800274 <CurError>
     2a8:	90 91 75 02 	lds	r25, 0x0275	; 0x800275 <CurError+0x1>
     2ac:	99 23       	and	r25, r25
     2ae:	1c f4       	brge	.+6      	; 0x2b6 <CalcEnterTime+0x12>
     2b0:	91 95       	neg	r25
     2b2:	81 95       	neg	r24
     2b4:	91 09       	sbc	r25, r1
     2b6:	0e 97       	sbiw	r24, 0x0e	; 14
     2b8:	0c f4       	brge	.+2      	; 0x2bc <CalcEnterTime+0x18>
     2ba:	d5 c0       	rjmp	.+426    	; 0x466 <__LOCK_REGION_LENGTH__+0x66>
     2bc:	80 91 74 02 	lds	r24, 0x0274	; 0x800274 <CurError>
     2c0:	90 91 75 02 	lds	r25, 0x0275	; 0x800275 <CurError+0x1>
     2c4:	99 23       	and	r25, r25
     2c6:	1c f4       	brge	.+6      	; 0x2ce <CalcEnterTime+0x2a>
     2c8:	91 95       	neg	r25
     2ca:	81 95       	neg	r24
     2cc:	91 09       	sbc	r25, r1
     2ce:	8e 50       	subi	r24, 0x0E	; 14
     2d0:	80 93 4b 02 	sts	0x024B, r24	; 0x80024b <Steps2Enter>
     2d4:	80 91 14 02 	lds	r24, 0x0214	; 0x800214 <Steps2Acc>
     2d8:	90 91 78 02 	lds	r25, 0x0278	; 0x800278 <accSteps>
     2dc:	89 1b       	sub	r24, r25
     2de:	80 93 4c 02 	sts	0x024C, r24	; 0x80024c <Steps2MIN>
     2e2:	80 91 4b 02 	lds	r24, 0x024B	; 0x80024b <Steps2Enter>
     2e6:	89 32       	cpi	r24, 0x29	; 41
     2e8:	08 f0       	brcs	.+2      	; 0x2ec <CalcEnterTime+0x48>
     2ea:	bf c0       	rjmp	.+382    	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
     2ec:	40 91 13 02 	lds	r20, 0x0213	; 0x800213 <Dir>
     2f0:	20 91 74 02 	lds	r18, 0x0274	; 0x800274 <CurError>
     2f4:	30 91 75 02 	lds	r19, 0x0275	; 0x800275 <CurError+0x1>
     2f8:	42 03       	mulsu	r20, r18
     2fa:	c0 01       	movw	r24, r0
     2fc:	43 9f       	mul	r20, r19
     2fe:	90 0d       	add	r25, r0
     300:	11 24       	eor	r1, r1
     302:	18 16       	cp	r1, r24
     304:	19 06       	cpc	r1, r25
     306:	44 f0       	brlt	.+16     	; 0x318 <CalcEnterTime+0x74>
     308:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <CurDelay>
     30c:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <CurDelay+0x1>
     310:	81 15       	cp	r24, r1
     312:	9a 40       	sbci	r25, 0x0A	; 10
     314:	08 f4       	brcc	.+2      	; 0x318 <CalcEnterTime+0x74>
     316:	50 c0       	rjmp	.+160    	; 0x3b8 <CalcEnterTime+0x114>
     318:	90 91 4c 02 	lds	r25, 0x024C	; 0x80024c <Steps2MIN>
     31c:	80 91 4b 02 	lds	r24, 0x024B	; 0x80024b <Steps2Enter>
     320:	89 17       	cp	r24, r25
     322:	a0 f4       	brcc	.+40     	; 0x34c <CalcEnterTime+0xa8>
     324:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <CurDelay>
     328:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <CurDelay+0x1>
     32c:	80 5f       	subi	r24, 0xF0	; 240
     32e:	92 40       	sbci	r25, 0x02	; 2
     330:	96 95       	lsr	r25
     332:	87 95       	ror	r24
     334:	40 91 4c 02 	lds	r20, 0x024C	; 0x80024c <Steps2MIN>
     338:	48 9f       	mul	r20, r24
     33a:	90 01       	movw	r18, r0
     33c:	49 9f       	mul	r20, r25
     33e:	30 0d       	add	r19, r0
     340:	11 24       	eor	r1, r1
     342:	30 93 51 02 	sts	0x0251, r19	; 0x800251 <enterTime+0x1>
     346:	20 93 50 02 	sts	0x0250, r18	; 0x800250 <enterTime>
     34a:	80 c0       	rjmp	.+256    	; 0x44c <__LOCK_REGION_LENGTH__+0x4c>
     34c:	80 91 4b 02 	lds	r24, 0x024B	; 0x80024b <Steps2Enter>
     350:	20 91 4c 02 	lds	r18, 0x024C	; 0x80024c <Steps2MIN>
     354:	90 e0       	ldi	r25, 0x00	; 0
     356:	82 1b       	sub	r24, r18
     358:	91 09       	sbc	r25, r1
     35a:	90 93 51 02 	sts	0x0251, r25	; 0x800251 <enterTime+0x1>
     35e:	80 93 50 02 	sts	0x0250, r24	; 0x800250 <enterTime>
     362:	40 91 50 02 	lds	r20, 0x0250	; 0x800250 <enterTime>
     366:	50 91 51 02 	lds	r21, 0x0251	; 0x800251 <enterTime+0x1>
     36a:	20 ef       	ldi	r18, 0xF0	; 240
     36c:	32 e0       	ldi	r19, 0x02	; 2
     36e:	42 9f       	mul	r20, r18
     370:	c0 01       	movw	r24, r0
     372:	43 9f       	mul	r20, r19
     374:	90 0d       	add	r25, r0
     376:	52 9f       	mul	r21, r18
     378:	90 0d       	add	r25, r0
     37a:	11 24       	eor	r1, r1
     37c:	90 93 51 02 	sts	0x0251, r25	; 0x800251 <enterTime+0x1>
     380:	80 93 50 02 	sts	0x0250, r24	; 0x800250 <enterTime>
     384:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <CurDelay>
     388:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <CurDelay+0x1>
     38c:	80 5f       	subi	r24, 0xF0	; 240
     38e:	92 40       	sbci	r25, 0x02	; 2
     390:	96 95       	lsr	r25
     392:	87 95       	ror	r24
     394:	40 91 4c 02 	lds	r20, 0x024C	; 0x80024c <Steps2MIN>
     398:	48 9f       	mul	r20, r24
     39a:	90 01       	movw	r18, r0
     39c:	49 9f       	mul	r20, r25
     39e:	30 0d       	add	r19, r0
     3a0:	11 24       	eor	r1, r1
     3a2:	80 91 50 02 	lds	r24, 0x0250	; 0x800250 <enterTime>
     3a6:	90 91 51 02 	lds	r25, 0x0251	; 0x800251 <enterTime+0x1>
     3aa:	82 0f       	add	r24, r18
     3ac:	93 1f       	adc	r25, r19
     3ae:	90 93 51 02 	sts	0x0251, r25	; 0x800251 <enterTime+0x1>
     3b2:	80 93 50 02 	sts	0x0250, r24	; 0x800250 <enterTime>
     3b6:	4a c0       	rjmp	.+148    	; 0x44c <__LOCK_REGION_LENGTH__+0x4c>
     3b8:	80 91 4b 02 	lds	r24, 0x024B	; 0x80024b <Steps2Enter>
     3bc:	20 91 4c 02 	lds	r18, 0x024C	; 0x80024c <Steps2MIN>
     3c0:	90 e0       	ldi	r25, 0x00	; 0
     3c2:	82 1b       	sub	r24, r18
     3c4:	91 09       	sbc	r25, r1
     3c6:	90 93 51 02 	sts	0x0251, r25	; 0x800251 <enterTime+0x1>
     3ca:	80 93 50 02 	sts	0x0250, r24	; 0x800250 <enterTime>
     3ce:	40 91 50 02 	lds	r20, 0x0250	; 0x800250 <enterTime>
     3d2:	50 91 51 02 	lds	r21, 0x0251	; 0x800251 <enterTime+0x1>
     3d6:	20 ef       	ldi	r18, 0xF0	; 240
     3d8:	32 e0       	ldi	r19, 0x02	; 2
     3da:	42 9f       	mul	r20, r18
     3dc:	c0 01       	movw	r24, r0
     3de:	43 9f       	mul	r20, r19
     3e0:	90 0d       	add	r25, r0
     3e2:	52 9f       	mul	r21, r18
     3e4:	90 0d       	add	r25, r0
     3e6:	11 24       	eor	r1, r1
     3e8:	90 93 51 02 	sts	0x0251, r25	; 0x800251 <enterTime+0x1>
     3ec:	80 93 50 02 	sts	0x0250, r24	; 0x800250 <enterTime>
     3f0:	20 91 76 02 	lds	r18, 0x0276	; 0x800276 <CurDelay>
     3f4:	30 91 77 02 	lds	r19, 0x0277	; 0x800277 <CurDelay+0x1>
     3f8:	80 e0       	ldi	r24, 0x00	; 0
     3fa:	9a e0       	ldi	r25, 0x0A	; 10
     3fc:	82 1b       	sub	r24, r18
     3fe:	93 0b       	sbc	r25, r19
     400:	96 95       	lsr	r25
     402:	87 95       	ror	r24
     404:	40 91 14 02 	lds	r20, 0x0214	; 0x800214 <Steps2Acc>
     408:	48 9f       	mul	r20, r24
     40a:	90 01       	movw	r18, r0
     40c:	49 9f       	mul	r20, r25
     40e:	30 0d       	add	r19, r0
     410:	11 24       	eor	r1, r1
     412:	80 91 50 02 	lds	r24, 0x0250	; 0x800250 <enterTime>
     416:	90 91 51 02 	lds	r25, 0x0251	; 0x800251 <enterTime+0x1>
     41a:	82 0f       	add	r24, r18
     41c:	93 1f       	adc	r25, r19
     41e:	90 93 51 02 	sts	0x0251, r25	; 0x800251 <enterTime+0x1>
     422:	80 93 50 02 	sts	0x0250, r24	; 0x800250 <enterTime>
     426:	40 91 14 02 	lds	r20, 0x0214	; 0x800214 <Steps2Acc>
     42a:	88 e8       	ldi	r24, 0x88	; 136
     42c:	93 e0       	ldi	r25, 0x03	; 3
     42e:	48 9f       	mul	r20, r24
     430:	90 01       	movw	r18, r0
     432:	49 9f       	mul	r20, r25
     434:	30 0d       	add	r19, r0
     436:	11 24       	eor	r1, r1
     438:	80 91 50 02 	lds	r24, 0x0250	; 0x800250 <enterTime>
     43c:	90 91 51 02 	lds	r25, 0x0251	; 0x800251 <enterTime+0x1>
     440:	82 0f       	add	r24, r18
     442:	93 1f       	adc	r25, r19
     444:	90 93 51 02 	sts	0x0251, r25	; 0x800251 <enterTime+0x1>
     448:	80 93 50 02 	sts	0x0250, r24	; 0x800250 <enterTime>
     44c:	20 91 50 02 	lds	r18, 0x0250	; 0x800250 <enterTime>
     450:	30 91 51 02 	lds	r19, 0x0251	; 0x800251 <enterTime+0x1>
     454:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
     458:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     45c:	82 17       	cp	r24, r18
     45e:	93 07       	cpc	r25, r19
     460:	30 f4       	brcc	.+12     	; 0x46e <__LOCK_REGION_LENGTH__+0x6e>
     462:	81 e0       	ldi	r24, 0x01	; 1
     464:	08 95       	ret
     466:	80 e0       	ldi	r24, 0x00	; 0
     468:	08 95       	ret
     46a:	81 e0       	ldi	r24, 0x01	; 1
     46c:	08 95       	ret
     46e:	80 e0       	ldi	r24, 0x00	; 0
     470:	08 95       	ret

00000472 <brakeMotor>:
     472:	85 b1       	in	r24, 0x05	; 5
     474:	80 78       	andi	r24, 0x80	; 128
     476:	85 b9       	out	0x05, r24	; 5
     478:	85 b1       	in	r24, 0x05	; 5
     47a:	8f 60       	ori	r24, 0x0F	; 15
     47c:	85 b9       	out	0x05, r24	; 5
     47e:	10 92 6e 02 	sts	0x026E, r1	; 0x80026e <MOTORFLAG>
     482:	80 91 6e 02 	lds	r24, 0x026E	; 0x80026e <MOTORFLAG>
     486:	08 95       	ret

00000488 <stopMotor>:
     488:	15 b8       	out	0x05, r1	; 5
     48a:	10 92 6e 02 	sts	0x026E, r1	; 0x80026e <MOTORFLAG>
     48e:	80 91 6e 02 	lds	r24, 0x026E	; 0x80026e <MOTORFLAG>
     492:	08 95       	ret

00000494 <Motor_init>:
     494:	84 b5       	in	r24, 0x24	; 36
     496:	83 68       	ori	r24, 0x83	; 131
     498:	84 bd       	out	0x24, r24	; 36
     49a:	85 b5       	in	r24, 0x25	; 37
     49c:	82 60       	ori	r24, 0x02	; 2
     49e:	85 bd       	out	0x25, r24	; 37
     4a0:	85 b3       	in	r24, 0x15	; 21
     4a2:	82 60       	ori	r24, 0x02	; 2
     4a4:	85 bb       	out	0x15, r24	; 21
     4a6:	17 bc       	out	0x27, r1	; 39
     4a8:	ef cf       	rjmp	.-34     	; 0x488 <stopMotor>
     4aa:	08 95       	ret

000004ac <motorTimerStart>:
     4ac:	e1 e2       	ldi	r30, 0x21	; 33
     4ae:	f1 e0       	ldi	r31, 0x01	; 1
     4b0:	80 81       	ld	r24, Z
     4b2:	88 60       	ori	r24, 0x08	; 8
     4b4:	80 83       	st	Z, r24
     4b6:	80 ef       	ldi	r24, 0xF0	; 240
     4b8:	90 e0       	ldi	r25, 0x00	; 0
     4ba:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x7c0129>
     4be:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x7c0128>
     4c2:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <__TEXT_REGION_LENGTH__+0x7c0125>
     4c6:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x7c0124>
     4ca:	a3 e7       	ldi	r26, 0x73	; 115
     4cc:	b0 e0       	ldi	r27, 0x00	; 0
     4ce:	8c 91       	ld	r24, X
     4d0:	82 60       	ori	r24, 0x02	; 2
     4d2:	8c 93       	st	X, r24
     4d4:	80 81       	ld	r24, Z
     4d6:	85 60       	ori	r24, 0x05	; 5
     4d8:	80 83       	st	Z, r24
     4da:	8a b3       	in	r24, 0x1a	; 26
     4dc:	82 60       	ori	r24, 0x02	; 2
     4de:	8a bb       	out	0x1a, r24	; 26
     4e0:	86 e9       	ldi	r24, 0x96	; 150
     4e2:	80 93 04 02 	sts	0x0204, r24	; 0x800204 <motorDecSpeed>
     4e6:	08 95       	ret

000004e8 <startMotor>:
     4e8:	85 b1       	in	r24, 0x05	; 5
     4ea:	80 78       	andi	r24, 0x80	; 128
     4ec:	85 b9       	out	0x05, r24	; 5
     4ee:	85 b1       	in	r24, 0x05	; 5
     4f0:	8b 60       	ori	r24, 0x0B	; 11
     4f2:	85 b9       	out	0x05, r24	; 5
     4f4:	16 bc       	out	0x26, r1	; 38
     4f6:	86 e9       	ldi	r24, 0x96	; 150
     4f8:	87 bd       	out	0x27, r24	; 39
     4fa:	80 91 6e 02 	lds	r24, 0x026E	; 0x80026e <MOTORFLAG>
     4fe:	81 11       	cpse	r24, r1
     500:	12 c0       	rjmp	.+36     	; 0x526 <startMotor+0x3e>
     502:	81 e0       	ldi	r24, 0x01	; 1
     504:	80 93 6e 02 	sts	0x026E, r24	; 0x80026e <MOTORFLAG>
     508:	d1 df       	rcall	.-94     	; 0x4ac <motorTimerStart>
     50a:	80 e0       	ldi	r24, 0x00	; 0
     50c:	94 e2       	ldi	r25, 0x24	; 36
     50e:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x7c0129>
     512:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x7c0128>
     516:	80 91 60 02 	lds	r24, 0x0260	; 0x800260 <runTime_d>
     51a:	90 91 61 02 	lds	r25, 0x0261	; 0x800261 <runTime_d+0x1>
     51e:	90 93 4f 02 	sts	0x024F, r25	; 0x80024f <motorTime_d+0x1>
     522:	80 93 4e 02 	sts	0x024E, r24	; 0x80024e <motorTime_d>
     526:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <__TEXT_REGION_LENGTH__+0x7c0125>
     52a:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x7c0124>
     52e:	80 91 6e 02 	lds	r24, 0x026E	; 0x80026e <MOTORFLAG>
     532:	08 95       	ret

00000534 <runMotor>:
     534:	85 b1       	in	r24, 0x05	; 5
     536:	80 78       	andi	r24, 0x80	; 128
     538:	85 b9       	out	0x05, r24	; 5
     53a:	85 b1       	in	r24, 0x05	; 5
     53c:	8b 60       	ori	r24, 0x0B	; 11
     53e:	85 b9       	out	0x05, r24	; 5
     540:	16 bc       	out	0x26, r1	; 38
     542:	86 e9       	ldi	r24, 0x96	; 150
     544:	87 bd       	out	0x27, r24	; 39
     546:	80 91 6e 02 	lds	r24, 0x026E	; 0x80026e <MOTORFLAG>
     54a:	81 11       	cpse	r24, r1
     54c:	0c c0       	rjmp	.+24     	; 0x566 <runMotor+0x32>
     54e:	ae df       	rcall	.-164    	; 0x4ac <motorTimerStart>
     550:	81 e0       	ldi	r24, 0x01	; 1
     552:	80 93 6e 02 	sts	0x026E, r24	; 0x80026e <MOTORFLAG>
     556:	80 91 60 02 	lds	r24, 0x0260	; 0x800260 <runTime_d>
     55a:	90 91 61 02 	lds	r25, 0x0261	; 0x800261 <runTime_d+0x1>
     55e:	90 93 4f 02 	sts	0x024F, r25	; 0x80024f <motorTime_d+0x1>
     562:	80 93 4e 02 	sts	0x024E, r24	; 0x80024e <motorTime_d>
     566:	80 91 6e 02 	lds	r24, 0x026E	; 0x80026e <MOTORFLAG>
     56a:	08 95       	ret

0000056c <motorTimerStop>:
     56c:	e1 e2       	ldi	r30, 0x21	; 33
     56e:	f1 e0       	ldi	r31, 0x01	; 1
     570:	80 81       	ld	r24, Z
     572:	8a 7f       	andi	r24, 0xFA	; 250
     574:	80 83       	st	Z, r24
     576:	08 95       	ret

00000578 <__vector_47>:
     578:	1f 92       	push	r1
     57a:	0f 92       	push	r0
     57c:	0f b6       	in	r0, 0x3f	; 63
     57e:	0f 92       	push	r0
     580:	11 24       	eor	r1, r1
     582:	0b b6       	in	r0, 0x3b	; 59
     584:	0f 92       	push	r0
     586:	2f 93       	push	r18
     588:	3f 93       	push	r19
     58a:	4f 93       	push	r20
     58c:	5f 93       	push	r21
     58e:	6f 93       	push	r22
     590:	7f 93       	push	r23
     592:	8f 93       	push	r24
     594:	9f 93       	push	r25
     596:	af 93       	push	r26
     598:	bf 93       	push	r27
     59a:	ef 93       	push	r30
     59c:	ff 93       	push	r31
     59e:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <motorDecSpeed>
     5a2:	82 50       	subi	r24, 0x02	; 2
     5a4:	80 93 04 02 	sts	0x0204, r24	; 0x800204 <motorDecSpeed>
     5a8:	83 e0       	ldi	r24, 0x03	; 3
     5aa:	90 e0       	ldi	r25, 0x00	; 0
     5ac:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x7c0129>
     5b0:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x7c0128>
     5b4:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <motorDecSpeed>
     5b8:	84 36       	cpi	r24, 0x64	; 100
     5ba:	30 f4       	brcc	.+12     	; 0x5c8 <__vector_47+0x50>
     5bc:	84 e6       	ldi	r24, 0x64	; 100
     5be:	80 93 04 02 	sts	0x0204, r24	; 0x800204 <motorDecSpeed>
     5c2:	10 92 6e 02 	sts	0x026E, r1	; 0x80026e <MOTORFLAG>
     5c6:	d2 df       	rcall	.-92     	; 0x56c <motorTimerStop>
     5c8:	16 bc       	out	0x26, r1	; 38
     5ca:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <motorDecSpeed>
     5ce:	87 bd       	out	0x27, r24	; 39
     5d0:	ff 91       	pop	r31
     5d2:	ef 91       	pop	r30
     5d4:	bf 91       	pop	r27
     5d6:	af 91       	pop	r26
     5d8:	9f 91       	pop	r25
     5da:	8f 91       	pop	r24
     5dc:	7f 91       	pop	r23
     5de:	6f 91       	pop	r22
     5e0:	5f 91       	pop	r21
     5e2:	4f 91       	pop	r20
     5e4:	3f 91       	pop	r19
     5e6:	2f 91       	pop	r18
     5e8:	0f 90       	pop	r0
     5ea:	0b be       	out	0x3b, r0	; 59
     5ec:	0f 90       	pop	r0
     5ee:	0f be       	out	0x3f, r0	; 63
     5f0:	0f 90       	pop	r0
     5f2:	1f 90       	pop	r1
     5f4:	18 95       	reti

000005f6 <ADC_Init>:
     5f6:	ec e7       	ldi	r30, 0x7C	; 124
     5f8:	f0 e0       	ldi	r31, 0x00	; 0
     5fa:	80 81       	ld	r24, Z
     5fc:	80 64       	ori	r24, 0x40	; 64
     5fe:	80 83       	st	Z, r24
     600:	80 81       	ld	r24, Z
     602:	81 60       	ori	r24, 0x01	; 1
     604:	80 83       	st	Z, r24
     606:	ea e7       	ldi	r30, 0x7A	; 122
     608:	f0 e0       	ldi	r31, 0x00	; 0
     60a:	80 81       	ld	r24, Z
     60c:	80 68       	ori	r24, 0x80	; 128
     60e:	80 83       	st	Z, r24
     610:	80 81       	ld	r24, Z
     612:	88 60       	ori	r24, 0x08	; 8
     614:	80 83       	st	Z, r24
     616:	80 81       	ld	r24, Z
     618:	83 60       	ori	r24, 0x03	; 3
     61a:	80 83       	st	Z, r24
     61c:	08 95       	ret

0000061e <classify>:
     61e:	80 3c       	cpi	r24, 0xC0	; 192
     620:	23 e0       	ldi	r18, 0x03	; 3
     622:	92 07       	cpc	r25, r18
     624:	48 f4       	brcc	.+18     	; 0x638 <classify+0x1a>
     626:	80 32       	cpi	r24, 0x20	; 32
     628:	23 e0       	ldi	r18, 0x03	; 3
     62a:	92 07       	cpc	r25, r18
     62c:	38 f4       	brcc	.+14     	; 0x63c <classify+0x1e>
     62e:	8c 32       	cpi	r24, 0x2C	; 44
     630:	91 40       	sbci	r25, 0x01	; 1
     632:	30 f0       	brcs	.+12     	; 0x640 <classify+0x22>
     634:	88 ec       	ldi	r24, 0xC8	; 200
     636:	08 95       	ret
     638:	82 e3       	ldi	r24, 0x32	; 50
     63a:	08 95       	ret
     63c:	86 e9       	ldi	r24, 0x96	; 150
     63e:	08 95       	ret
     640:	84 e6       	ldi	r24, 0x64	; 100
     642:	08 95       	ret

00000644 <debounce>:
     644:	21 e0       	ldi	r18, 0x01	; 1
     646:	30 e0       	ldi	r19, 0x00	; 0
     648:	08 2e       	mov	r0, r24
     64a:	02 c0       	rjmp	.+4      	; 0x650 <debounce+0xc>
     64c:	22 0f       	add	r18, r18
     64e:	33 1f       	adc	r19, r19
     650:	0a 94       	dec	r0
     652:	e2 f7       	brpl	.-8      	; 0x64c <debounce+0x8>
     654:	20 93 48 02 	sts	0x0248, r18	; 0x800248 <__data_end>
     658:	01 c0       	rjmp	.+2      	; 0x65c <debounce+0x18>
     65a:	66 0f       	add	r22, r22
     65c:	8a 95       	dec	r24
     65e:	ea f7       	brpl	.-6      	; 0x65a <debounce+0x16>
     660:	10 92 4a 02 	sts	0x024A, r1	; 0x80024a <countCheck+0x1>
     664:	10 92 49 02 	sts	0x0249, r1	; 0x800249 <countCheck>
     668:	10 92 4a 02 	sts	0x024A, r1	; 0x80024a <countCheck+0x1>
     66c:	10 92 49 02 	sts	0x0249, r1	; 0x800249 <countCheck>
     670:	0f c0       	rjmp	.+30     	; 0x690 <debounce+0x4c>
     672:	99 b1       	in	r25, 0x09	; 9
     674:	80 91 48 02 	lds	r24, 0x0248	; 0x800248 <__data_end>
     678:	89 23       	and	r24, r25
     67a:	68 13       	cpse	r22, r24
     67c:	12 c0       	rjmp	.+36     	; 0x6a2 <debounce+0x5e>
     67e:	80 91 49 02 	lds	r24, 0x0249	; 0x800249 <countCheck>
     682:	90 91 4a 02 	lds	r25, 0x024A	; 0x80024a <countCheck+0x1>
     686:	01 96       	adiw	r24, 0x01	; 1
     688:	90 93 4a 02 	sts	0x024A, r25	; 0x80024a <countCheck+0x1>
     68c:	80 93 49 02 	sts	0x0249, r24	; 0x800249 <countCheck>
     690:	80 91 49 02 	lds	r24, 0x0249	; 0x800249 <countCheck>
     694:	90 91 4a 02 	lds	r25, 0x024A	; 0x80024a <countCheck+0x1>
     698:	84 17       	cp	r24, r20
     69a:	95 07       	cpc	r25, r21
     69c:	50 f3       	brcs	.-44     	; 0x672 <debounce+0x2e>
     69e:	81 e0       	ldi	r24, 0x01	; 1
     6a0:	08 95       	ret
     6a2:	80 e0       	ldi	r24, 0x00	; 0
     6a4:	08 95       	ret

000006a6 <debouncePINJ>:
     6a6:	21 e0       	ldi	r18, 0x01	; 1
     6a8:	30 e0       	ldi	r19, 0x00	; 0
     6aa:	08 2e       	mov	r0, r24
     6ac:	02 c0       	rjmp	.+4      	; 0x6b2 <debouncePINJ+0xc>
     6ae:	22 0f       	add	r18, r18
     6b0:	33 1f       	adc	r19, r19
     6b2:	0a 94       	dec	r0
     6b4:	e2 f7       	brpl	.-8      	; 0x6ae <debouncePINJ+0x8>
     6b6:	20 93 48 02 	sts	0x0248, r18	; 0x800248 <__data_end>
     6ba:	01 c0       	rjmp	.+2      	; 0x6be <debouncePINJ+0x18>
     6bc:	66 0f       	add	r22, r22
     6be:	8a 95       	dec	r24
     6c0:	ea f7       	brpl	.-6      	; 0x6bc <debouncePINJ+0x16>
     6c2:	10 92 4a 02 	sts	0x024A, r1	; 0x80024a <countCheck+0x1>
     6c6:	10 92 49 02 	sts	0x0249, r1	; 0x800249 <countCheck>
     6ca:	10 92 4a 02 	sts	0x024A, r1	; 0x80024a <countCheck+0x1>
     6ce:	10 92 49 02 	sts	0x0249, r1	; 0x800249 <countCheck>
     6d2:	10 c0       	rjmp	.+32     	; 0x6f4 <debouncePINJ+0x4e>
     6d4:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__TEXT_REGION_LENGTH__+0x7c0103>
     6d8:	80 91 48 02 	lds	r24, 0x0248	; 0x800248 <__data_end>
     6dc:	89 23       	and	r24, r25
     6de:	68 13       	cpse	r22, r24
     6e0:	12 c0       	rjmp	.+36     	; 0x706 <debouncePINJ+0x60>
     6e2:	80 91 49 02 	lds	r24, 0x0249	; 0x800249 <countCheck>
     6e6:	90 91 4a 02 	lds	r25, 0x024A	; 0x80024a <countCheck+0x1>
     6ea:	01 96       	adiw	r24, 0x01	; 1
     6ec:	90 93 4a 02 	sts	0x024A, r25	; 0x80024a <countCheck+0x1>
     6f0:	80 93 49 02 	sts	0x0249, r24	; 0x800249 <countCheck>
     6f4:	80 91 49 02 	lds	r24, 0x0249	; 0x800249 <countCheck>
     6f8:	90 91 4a 02 	lds	r25, 0x024A	; 0x80024a <countCheck+0x1>
     6fc:	84 17       	cp	r24, r20
     6fe:	95 07       	cpc	r25, r21
     700:	48 f3       	brcs	.-46     	; 0x6d4 <debouncePINJ+0x2e>
     702:	81 e0       	ldi	r24, 0x01	; 1
     704:	08 95       	ret
     706:	80 e0       	ldi	r24, 0x00	; 0
     708:	08 95       	ret

0000070a <updateCount>:
     70a:	88 3c       	cpi	r24, 0xC8	; 200
     70c:	31 f4       	brne	.+12     	; 0x71a <updateCount+0x10>
     70e:	80 91 55 02 	lds	r24, 0x0255	; 0x800255 <countS>
     712:	8f 5f       	subi	r24, 0xFF	; 255
     714:	80 93 55 02 	sts	0x0255, r24	; 0x800255 <countS>
     718:	15 c0       	rjmp	.+42     	; 0x744 <updateCount+0x3a>
     71a:	86 39       	cpi	r24, 0x96	; 150
     71c:	31 f4       	brne	.+12     	; 0x72a <updateCount+0x20>
     71e:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <countW>
     722:	8f 5f       	subi	r24, 0xFF	; 255
     724:	80 93 56 02 	sts	0x0256, r24	; 0x800256 <countW>
     728:	0d c0       	rjmp	.+26     	; 0x744 <updateCount+0x3a>
     72a:	84 36       	cpi	r24, 0x64	; 100
     72c:	31 f4       	brne	.+12     	; 0x73a <updateCount+0x30>
     72e:	80 91 54 02 	lds	r24, 0x0254	; 0x800254 <countA>
     732:	8f 5f       	subi	r24, 0xFF	; 255
     734:	80 93 54 02 	sts	0x0254, r24	; 0x800254 <countA>
     738:	05 c0       	rjmp	.+10     	; 0x744 <updateCount+0x3a>
     73a:	80 91 57 02 	lds	r24, 0x0257	; 0x800257 <countB>
     73e:	8f 5f       	subi	r24, 0xFF	; 255
     740:	80 93 57 02 	sts	0x0257, r24	; 0x800257 <countB>
     744:	81 e0       	ldi	r24, 0x01	; 1
     746:	08 95       	ret

00000748 <mTimer_init>:
     748:	e1 e8       	ldi	r30, 0x81	; 129
     74a:	f0 e0       	ldi	r31, 0x00	; 0
     74c:	80 81       	ld	r24, Z
     74e:	82 60       	ori	r24, 0x02	; 2
     750:	80 83       	st	Z, r24
     752:	80 81       	ld	r24, Z
     754:	88 60       	ori	r24, 0x08	; 8
     756:	80 83       	st	Z, r24
     758:	88 ee       	ldi	r24, 0xE8	; 232
     75a:	93 e0       	ldi	r25, 0x03	; 3
     75c:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7c0089>
     760:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7c0088>
     764:	08 95       	ret

00000766 <runTimerStart>:
     766:	e1 ea       	ldi	r30, 0xA1	; 161
     768:	f0 e0       	ldi	r31, 0x00	; 0
     76a:	80 81       	ld	r24, Z
     76c:	88 60       	ori	r24, 0x08	; 8
     76e:	80 83       	st	Z, r24
     770:	87 e0       	ldi	r24, 0x07	; 7
     772:	90 e0       	ldi	r25, 0x00	; 0
     774:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7c00a9>
     778:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7c00a8>
     77c:	10 92 a5 00 	sts	0x00A5, r1	; 0x8000a5 <__TEXT_REGION_LENGTH__+0x7c00a5>
     780:	10 92 a4 00 	sts	0x00A4, r1	; 0x8000a4 <__TEXT_REGION_LENGTH__+0x7c00a4>
     784:	a2 e7       	ldi	r26, 0x72	; 114
     786:	b0 e0       	ldi	r27, 0x00	; 0
     788:	8c 91       	ld	r24, X
     78a:	82 60       	ori	r24, 0x02	; 2
     78c:	8c 93       	st	X, r24
     78e:	80 81       	ld	r24, Z
     790:	85 60       	ori	r24, 0x05	; 5
     792:	80 83       	st	Z, r24
     794:	89 b3       	in	r24, 0x19	; 25
     796:	82 60       	ori	r24, 0x02	; 2
     798:	89 bb       	out	0x19, r24	; 25
     79a:	08 95       	ret

0000079c <runTimerStop>:
     79c:	e1 ea       	ldi	r30, 0xA1	; 161
     79e:	f0 e0       	ldi	r31, 0x00	; 0
     7a0:	80 81       	ld	r24, Z
     7a2:	8a 7f       	andi	r24, 0xFA	; 250
     7a4:	80 83       	st	Z, r24
     7a6:	08 95       	ret

000007a8 <runTimerResume>:
     7a8:	e1 ea       	ldi	r30, 0xA1	; 161
     7aa:	f0 e0       	ldi	r31, 0x00	; 0
     7ac:	80 81       	ld	r24, Z
     7ae:	85 60       	ori	r24, 0x05	; 5
     7b0:	80 83       	st	Z, r24
     7b2:	08 95       	ret

000007b4 <__vector_42>:
     7b4:	1f 92       	push	r1
     7b6:	0f 92       	push	r0
     7b8:	0f b6       	in	r0, 0x3f	; 63
     7ba:	0f 92       	push	r0
     7bc:	11 24       	eor	r1, r1
     7be:	8f 93       	push	r24
     7c0:	9f 93       	push	r25
     7c2:	80 91 60 02 	lds	r24, 0x0260	; 0x800260 <runTime_d>
     7c6:	90 91 61 02 	lds	r25, 0x0261	; 0x800261 <runTime_d+0x1>
     7ca:	01 96       	adiw	r24, 0x01	; 1
     7cc:	90 93 61 02 	sts	0x0261, r25	; 0x800261 <runTime_d+0x1>
     7d0:	80 93 60 02 	sts	0x0260, r24	; 0x800260 <runTime_d>
     7d4:	9f 91       	pop	r25
     7d6:	8f 91       	pop	r24
     7d8:	0f 90       	pop	r0
     7da:	0f be       	out	0x3f, r0	; 63
     7dc:	0f 90       	pop	r0
     7de:	1f 90       	pop	r1
     7e0:	18 95       	reti

000007e2 <__vector_default>:
     7e2:	1f 92       	push	r1
     7e4:	0f 92       	push	r0
     7e6:	0f b6       	in	r0, 0x3f	; 63
     7e8:	0f 92       	push	r0
     7ea:	11 24       	eor	r1, r1
     7ec:	8f 93       	push	r24
     7ee:	8f ef       	ldi	r24, 0xFF	; 255
     7f0:	88 b9       	out	0x08, r24	; 8
     7f2:	8f 91       	pop	r24
     7f4:	0f 90       	pop	r0
     7f6:	0f be       	out	0x3f, r0	; 63
     7f8:	0f 90       	pop	r0
     7fa:	1f 90       	pop	r1
     7fc:	18 95       	reti

000007fe <dispComplete>:
     7fe:	60 e0       	ldi	r22, 0x00	; 0
     800:	81 e0       	ldi	r24, 0x01	; 1
     802:	64 d1       	rcall	.+712    	; 0xacc <LCDByte>
     804:	60 e0       	ldi	r22, 0x00	; 0
     806:	81 e0       	ldi	r24, 0x01	; 1
     808:	61 d1       	rcall	.+706    	; 0xacc <LCDByte>
     80a:	85 e1       	ldi	r24, 0x15	; 21
     80c:	92 e0       	ldi	r25, 0x02	; 2
     80e:	d6 d1       	rcall	.+940    	; 0xbbc <LCDWriteString>
     810:	61 e0       	ldi	r22, 0x01	; 1
     812:	80 e0       	ldi	r24, 0x00	; 0
     814:	3f d2       	rcall	.+1150   	; 0xc94 <LCDGotoXY>
     816:	80 91 57 02 	lds	r24, 0x0257	; 0x800257 <countB>
     81a:	62 e0       	ldi	r22, 0x02	; 2
     81c:	70 e0       	ldi	r23, 0x00	; 0
     81e:	90 e0       	ldi	r25, 0x00	; 0
     820:	da d1       	rcall	.+948    	; 0xbd6 <LCDWriteInt>
     822:	83 e2       	ldi	r24, 0x23	; 35
     824:	92 e0       	ldi	r25, 0x02	; 2
     826:	ca d1       	rcall	.+916    	; 0xbbc <LCDWriteString>
     828:	61 e0       	ldi	r22, 0x01	; 1
     82a:	80 e0       	ldi	r24, 0x00	; 0
     82c:	33 d2       	rcall	.+1126   	; 0xc94 <LCDGotoXY>
     82e:	80 91 54 02 	lds	r24, 0x0254	; 0x800254 <countA>
     832:	62 e0       	ldi	r22, 0x02	; 2
     834:	70 e0       	ldi	r23, 0x00	; 0
     836:	90 e0       	ldi	r25, 0x00	; 0
     838:	ce d1       	rcall	.+924    	; 0xbd6 <LCDWriteInt>
     83a:	83 e2       	ldi	r24, 0x23	; 35
     83c:	92 e0       	ldi	r25, 0x02	; 2
     83e:	be d1       	rcall	.+892    	; 0xbbc <LCDWriteString>
     840:	61 e0       	ldi	r22, 0x01	; 1
     842:	80 e0       	ldi	r24, 0x00	; 0
     844:	27 d2       	rcall	.+1102   	; 0xc94 <LCDGotoXY>
     846:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <countW>
     84a:	62 e0       	ldi	r22, 0x02	; 2
     84c:	70 e0       	ldi	r23, 0x00	; 0
     84e:	90 e0       	ldi	r25, 0x00	; 0
     850:	c2 d1       	rcall	.+900    	; 0xbd6 <LCDWriteInt>
     852:	83 e2       	ldi	r24, 0x23	; 35
     854:	92 e0       	ldi	r25, 0x02	; 2
     856:	b2 d1       	rcall	.+868    	; 0xbbc <LCDWriteString>
     858:	61 e0       	ldi	r22, 0x01	; 1
     85a:	80 e0       	ldi	r24, 0x00	; 0
     85c:	1b d2       	rcall	.+1078   	; 0xc94 <LCDGotoXY>
     85e:	80 91 55 02 	lds	r24, 0x0255	; 0x800255 <countS>
     862:	62 e0       	ldi	r22, 0x02	; 2
     864:	70 e0       	ldi	r23, 0x00	; 0
     866:	90 e0       	ldi	r25, 0x00	; 0
     868:	b6 d1       	rcall	.+876    	; 0xbd6 <LCDWriteInt>
     86a:	83 e2       	ldi	r24, 0x23	; 35
     86c:	92 e0       	ldi	r25, 0x02	; 2
     86e:	a6 d1       	rcall	.+844    	; 0xbbc <LCDWriteString>
     870:	61 e0       	ldi	r22, 0x01	; 1
     872:	80 e0       	ldi	r24, 0x00	; 0
     874:	0f d2       	rcall	.+1054   	; 0xc94 <LCDGotoXY>
     876:	80 91 64 02 	lds	r24, 0x0264	; 0x800264 <countSort>
     87a:	62 e0       	ldi	r22, 0x02	; 2
     87c:	70 e0       	ldi	r23, 0x00	; 0
     87e:	90 e0       	ldi	r25, 0x00	; 0
     880:	aa c1       	rjmp	.+852    	; 0xbd6 <LCDWriteInt>
     882:	08 95       	ret

00000884 <dispStatus>:
     884:	60 e0       	ldi	r22, 0x00	; 0
     886:	81 e0       	ldi	r24, 0x01	; 1
     888:	21 d1       	rcall	.+578    	; 0xacc <LCDByte>
     88a:	60 e0       	ldi	r22, 0x00	; 0
     88c:	80 e0       	ldi	r24, 0x00	; 0
     88e:	02 d2       	rcall	.+1028   	; 0xc94 <LCDGotoXY>
     890:	80 91 64 02 	lds	r24, 0x0264	; 0x800264 <countSort>
     894:	62 e0       	ldi	r22, 0x02	; 2
     896:	70 e0       	ldi	r23, 0x00	; 0
     898:	90 e0       	ldi	r25, 0x00	; 0
     89a:	9d d1       	rcall	.+826    	; 0xbd6 <LCDWriteInt>
     89c:	60 e0       	ldi	r22, 0x00	; 0
     89e:	82 e0       	ldi	r24, 0x02	; 2
     8a0:	f9 d1       	rcall	.+1010   	; 0xc94 <LCDGotoXY>
     8a2:	85 e2       	ldi	r24, 0x25	; 37
     8a4:	92 e0       	ldi	r25, 0x02	; 2
     8a6:	8a d1       	rcall	.+788    	; 0xbbc <LCDWriteString>
     8a8:	60 e0       	ldi	r22, 0x00	; 0
     8aa:	83 e0       	ldi	r24, 0x03	; 3
     8ac:	f3 d1       	rcall	.+998    	; 0xc94 <LCDGotoXY>
     8ae:	80 91 65 02 	lds	r24, 0x0265	; 0x800265 <countPart>
     8b2:	62 e0       	ldi	r22, 0x02	; 2
     8b4:	70 e0       	ldi	r23, 0x00	; 0
     8b6:	90 e0       	ldi	r25, 0x00	; 0
     8b8:	8e d1       	rcall	.+796    	; 0xbd6 <LCDWriteInt>
     8ba:	60 e0       	ldi	r22, 0x00	; 0
     8bc:	85 e0       	ldi	r24, 0x05	; 5
     8be:	ea d1       	rcall	.+980    	; 0xc94 <LCDGotoXY>
     8c0:	87 e2       	ldi	r24, 0x27	; 39
     8c2:	92 e0       	ldi	r25, 0x02	; 2
     8c4:	7b d1       	rcall	.+758    	; 0xbbc <LCDWriteString>
     8c6:	60 e0       	ldi	r22, 0x00	; 0
     8c8:	86 e0       	ldi	r24, 0x06	; 6
     8ca:	e4 d1       	rcall	.+968    	; 0xc94 <LCDGotoXY>
     8cc:	80 91 57 02 	lds	r24, 0x0257	; 0x800257 <countB>
     8d0:	61 e0       	ldi	r22, 0x01	; 1
     8d2:	70 e0       	ldi	r23, 0x00	; 0
     8d4:	90 e0       	ldi	r25, 0x00	; 0
     8d6:	7f d1       	rcall	.+766    	; 0xbd6 <LCDWriteInt>
     8d8:	60 e0       	ldi	r22, 0x00	; 0
     8da:	87 e0       	ldi	r24, 0x07	; 7
     8dc:	db d1       	rcall	.+950    	; 0xc94 <LCDGotoXY>
     8de:	80 91 54 02 	lds	r24, 0x0254	; 0x800254 <countA>
     8e2:	61 e0       	ldi	r22, 0x01	; 1
     8e4:	70 e0       	ldi	r23, 0x00	; 0
     8e6:	90 e0       	ldi	r25, 0x00	; 0
     8e8:	76 d1       	rcall	.+748    	; 0xbd6 <LCDWriteInt>
     8ea:	60 e0       	ldi	r22, 0x00	; 0
     8ec:	88 e0       	ldi	r24, 0x08	; 8
     8ee:	d2 d1       	rcall	.+932    	; 0xc94 <LCDGotoXY>
     8f0:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <countW>
     8f4:	61 e0       	ldi	r22, 0x01	; 1
     8f6:	70 e0       	ldi	r23, 0x00	; 0
     8f8:	90 e0       	ldi	r25, 0x00	; 0
     8fa:	6d d1       	rcall	.+730    	; 0xbd6 <LCDWriteInt>
     8fc:	60 e0       	ldi	r22, 0x00	; 0
     8fe:	89 e0       	ldi	r24, 0x09	; 9
     900:	c9 d1       	rcall	.+914    	; 0xc94 <LCDGotoXY>
     902:	80 91 55 02 	lds	r24, 0x0255	; 0x800255 <countS>
     906:	61 e0       	ldi	r22, 0x01	; 1
     908:	70 e0       	ldi	r23, 0x00	; 0
     90a:	90 e0       	ldi	r25, 0x00	; 0
     90c:	64 d1       	rcall	.+712    	; 0xbd6 <LCDWriteInt>
     90e:	60 e0       	ldi	r22, 0x00	; 0
     910:	8a e0       	ldi	r24, 0x0A	; 10
     912:	c0 d1       	rcall	.+896    	; 0xc94 <LCDGotoXY>
     914:	89 e2       	ldi	r24, 0x29	; 41
     916:	92 e0       	ldi	r25, 0x02	; 2
     918:	51 d1       	rcall	.+674    	; 0xbbc <LCDWriteString>
     91a:	60 e0       	ldi	r22, 0x00	; 0
     91c:	8c e0       	ldi	r24, 0x0C	; 12
     91e:	ba d1       	rcall	.+884    	; 0xc94 <LCDGotoXY>
     920:	83 e3       	ldi	r24, 0x33	; 51
     922:	92 e0       	ldi	r25, 0x02	; 2
     924:	4b d1       	rcall	.+662    	; 0xbbc <LCDWriteString>
     926:	60 e0       	ldi	r22, 0x00	; 0
     928:	8d e0       	ldi	r24, 0x0D	; 13
     92a:	b4 d1       	rcall	.+872    	; 0xc94 <LCDGotoXY>
     92c:	20 91 60 02 	lds	r18, 0x0260	; 0x800260 <runTime_d>
     930:	30 91 61 02 	lds	r19, 0x0261	; 0x800261 <runTime_d+0x1>
     934:	36 95       	lsr	r19
     936:	27 95       	ror	r18
     938:	36 95       	lsr	r19
     93a:	27 95       	ror	r18
     93c:	ab e7       	ldi	r26, 0x7B	; 123
     93e:	b4 e1       	ldi	r27, 0x14	; 20
     940:	0e 94 13 0d 	call	0x1a26	; 0x1a26 <__umulhisi3>
     944:	63 e0       	ldi	r22, 0x03	; 3
     946:	70 e0       	ldi	r23, 0x00	; 0
     948:	96 95       	lsr	r25
     94a:	87 95       	ror	r24
     94c:	44 d1       	rcall	.+648    	; 0xbd6 <LCDWriteInt>
     94e:	61 e0       	ldi	r22, 0x01	; 1
     950:	80 e0       	ldi	r24, 0x00	; 0
     952:	a0 d1       	rcall	.+832    	; 0xc94 <LCDGotoXY>
     954:	80 91 11 02 	lds	r24, 0x0211	; 0x800211 <CurPosition>
     958:	63 e0       	ldi	r22, 0x03	; 3
     95a:	70 e0       	ldi	r23, 0x00	; 0
     95c:	90 e0       	ldi	r25, 0x00	; 0
     95e:	3b d1       	rcall	.+630    	; 0xbd6 <LCDWriteInt>
     960:	61 e0       	ldi	r22, 0x01	; 1
     962:	83 e0       	ldi	r24, 0x03	; 3
     964:	97 d1       	rcall	.+814    	; 0xc94 <LCDGotoXY>
     966:	8b e2       	ldi	r24, 0x2B	; 43
     968:	92 e0       	ldi	r25, 0x02	; 2
     96a:	28 d1       	rcall	.+592    	; 0xbbc <LCDWriteString>
     96c:	61 e0       	ldi	r22, 0x01	; 1
     96e:	84 e0       	ldi	r24, 0x04	; 4
     970:	91 d1       	rcall	.+802    	; 0xc94 <LCDGotoXY>
     972:	e0 91 64 02 	lds	r30, 0x0264	; 0x800264 <countSort>
     976:	f0 e0       	ldi	r31, 0x00	; 0
     978:	e7 58       	subi	r30, 0x87	; 135
     97a:	fd 4f       	sbci	r31, 0xFD	; 253
     97c:	80 81       	ld	r24, Z
     97e:	63 e0       	ldi	r22, 0x03	; 3
     980:	70 e0       	ldi	r23, 0x00	; 0
     982:	90 e0       	ldi	r25, 0x00	; 0
     984:	28 d1       	rcall	.+592    	; 0xbd6 <LCDWriteInt>
     986:	61 e0       	ldi	r22, 0x01	; 1
     988:	8c e0       	ldi	r24, 0x0C	; 12
     98a:	84 d1       	rcall	.+776    	; 0xc94 <LCDGotoXY>
     98c:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <adcDisp>
     990:	90 91 06 02 	lds	r25, 0x0206	; 0x800206 <adcDisp+0x1>
     994:	64 e0       	ldi	r22, 0x04	; 4
     996:	70 e0       	ldi	r23, 0x00	; 0
     998:	1e c1       	rjmp	.+572    	; 0xbd6 <LCDWriteInt>
     99a:	08 95       	ret

0000099c <dispPause>:
}

extern volatile char ROLLFLAG;
void dispPause(void)
{
	LCDClear();
     99c:	60 e0       	ldi	r22, 0x00	; 0
     99e:	81 e0       	ldi	r24, 0x01	; 1
     9a0:	95 d0       	rcall	.+298    	; 0xacc <LCDByte>
	LCDWriteString("B  A  W  S  O");
     9a2:	8a e3       	ldi	r24, 0x3A	; 58
     9a4:	92 e0       	ldi	r25, 0x02	; 2
     9a6:	0a d1       	rcall	.+532    	; 0xbbc <LCDWriteString>
	LCDWriteIntXY(0,1, countB, 2);
     9a8:	61 e0       	ldi	r22, 0x01	; 1
     9aa:	80 e0       	ldi	r24, 0x00	; 0
     9ac:	73 d1       	rcall	.+742    	; 0xc94 <LCDGotoXY>
     9ae:	80 91 57 02 	lds	r24, 0x0257	; 0x800257 <countB>
     9b2:	62 e0       	ldi	r22, 0x02	; 2
     9b4:	70 e0       	ldi	r23, 0x00	; 0
     9b6:	90 e0       	ldi	r25, 0x00	; 0
     9b8:	0e d1       	rcall	.+540    	; 0xbd6 <LCDWriteInt>
	LCDWriteString(" ");
     9ba:	83 e2       	ldi	r24, 0x23	; 35
     9bc:	92 e0       	ldi	r25, 0x02	; 2
     9be:	fe d0       	rcall	.+508    	; 0xbbc <LCDWriteString>
	LCDWriteIntXY(0,1, countA, 2);
     9c0:	61 e0       	ldi	r22, 0x01	; 1
     9c2:	80 e0       	ldi	r24, 0x00	; 0
     9c4:	67 d1       	rcall	.+718    	; 0xc94 <LCDGotoXY>
     9c6:	80 91 54 02 	lds	r24, 0x0254	; 0x800254 <countA>
     9ca:	62 e0       	ldi	r22, 0x02	; 2
     9cc:	70 e0       	ldi	r23, 0x00	; 0
     9ce:	90 e0       	ldi	r25, 0x00	; 0
     9d0:	02 d1       	rcall	.+516    	; 0xbd6 <LCDWriteInt>
	LCDWriteString(" ");
     9d2:	83 e2       	ldi	r24, 0x23	; 35
     9d4:	92 e0       	ldi	r25, 0x02	; 2
     9d6:	f2 d0       	rcall	.+484    	; 0xbbc <LCDWriteString>
     9d8:	61 e0       	ldi	r22, 0x01	; 1
	LCDWriteIntXY(0,1, countW, 2);
     9da:	80 e0       	ldi	r24, 0x00	; 0
     9dc:	5b d1       	rcall	.+694    	; 0xc94 <LCDGotoXY>
     9de:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <countW>
     9e2:	62 e0       	ldi	r22, 0x02	; 2
     9e4:	70 e0       	ldi	r23, 0x00	; 0
     9e6:	90 e0       	ldi	r25, 0x00	; 0
     9e8:	f6 d0       	rcall	.+492    	; 0xbd6 <LCDWriteInt>
	LCDWriteString(" ");
     9ea:	83 e2       	ldi	r24, 0x23	; 35
     9ec:	92 e0       	ldi	r25, 0x02	; 2
     9ee:	e6 d0       	rcall	.+460    	; 0xbbc <LCDWriteString>
	LCDWriteIntXY(0,1, countS, 2);
     9f0:	61 e0       	ldi	r22, 0x01	; 1
     9f2:	80 e0       	ldi	r24, 0x00	; 0
     9f4:	4f d1       	rcall	.+670    	; 0xc94 <LCDGotoXY>
     9f6:	80 91 55 02 	lds	r24, 0x0255	; 0x800255 <countS>
     9fa:	62 e0       	ldi	r22, 0x02	; 2
     9fc:	70 e0       	ldi	r23, 0x00	; 0
     9fe:	90 e0       	ldi	r25, 0x00	; 0
     a00:	ea d0       	rcall	.+468    	; 0xbd6 <LCDWriteInt>
	LCDWriteString(" ");
     a02:	83 e2       	ldi	r24, 0x23	; 35
     a04:	92 e0       	ldi	r25, 0x02	; 2
     a06:	da d0       	rcall	.+436    	; 0xbbc <LCDWriteString>
     a08:	80 91 6c 02 	lds	r24, 0x026C	; 0x80026c <ROLLFLAG>
	if(ROLLFLAG)
     a0c:	88 23       	and	r24, r24
     a0e:	89 f0       	breq	.+34     	; 0xa32 <dispPause+0x96>
     a10:	61 e0       	ldi	r22, 0x01	; 1
	{
		LCDWriteIntXY(0,1, countPart + (PARTS_SIZE- countSort), 2);	
     a12:	80 e0       	ldi	r24, 0x00	; 0
     a14:	3f d1       	rcall	.+638    	; 0xc94 <LCDGotoXY>
     a16:	20 91 65 02 	lds	r18, 0x0265	; 0x800265 <countPart>
     a1a:	30 91 64 02 	lds	r19, 0x0264	; 0x800264 <countSort>
     a1e:	84 e6       	ldi	r24, 0x64	; 100
     a20:	90 e0       	ldi	r25, 0x00	; 0
     a22:	83 1b       	sub	r24, r19
     a24:	91 09       	sbc	r25, r1
     a26:	62 e0       	ldi	r22, 0x02	; 2
     a28:	70 e0       	ldi	r23, 0x00	; 0
     a2a:	82 0f       	add	r24, r18
     a2c:	91 1d       	adc	r25, r1
     a2e:	d3 c0       	rjmp	.+422    	; 0xbd6 <LCDWriteInt>
     a30:	08 95       	ret
	}else
	{
		LCDWriteIntXY(0,1, countPart - countSort, 2);	
     a32:	61 e0       	ldi	r22, 0x01	; 1
     a34:	80 e0       	ldi	r24, 0x00	; 0
     a36:	2e d1       	rcall	.+604    	; 0xc94 <LCDGotoXY>
     a38:	80 91 65 02 	lds	r24, 0x0265	; 0x800265 <countPart>
     a3c:	20 91 64 02 	lds	r18, 0x0264	; 0x800264 <countSort>
     a40:	90 e0       	ldi	r25, 0x00	; 0
     a42:	62 e0       	ldi	r22, 0x02	; 2
     a44:	70 e0       	ldi	r23, 0x00	; 0
     a46:	82 1b       	sub	r24, r18
     a48:	91 09       	sbc	r25, r1
     a4a:	c5 c0       	rjmp	.+394    	; 0xbd6 <LCDWriteInt>
     a4c:	08 95       	ret

00000a4e <LCDBusyLoop>:
	//This function waits till lcd is BUSY

	uint8_t busy,status=0x00,temp;

	//Change Port to input type because we are reading data
	LCD_DATA_DDR&=0xF0;
     a4e:	87 b1       	in	r24, 0x07	; 7
     a50:	80 7f       	andi	r24, 0xF0	; 240
     a52:	87 b9       	out	0x07, r24	; 7

	//change LCD mode
	SET_RW();		//Read mode
     a54:	88 b1       	in	r24, 0x08	; 8
     a56:	80 62       	ori	r24, 0x20	; 32
     a58:	88 b9       	out	0x08, r24	; 8
	CLEAR_RS();		//Read status
     a5a:	88 b1       	in	r24, 0x08	; 8
     a5c:	8f 7b       	andi	r24, 0xBF	; 191
     a5e:	88 b9       	out	0x08, r24	; 8
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     a60:	82 e0       	ldi	r24, 0x02	; 2
     a62:	8a 95       	dec	r24
     a64:	f1 f7       	brne	.-4      	; 0xa62 <LCDBusyLoop+0x14>
     a66:	00 c0       	rjmp	.+0      	; 0xa68 <LCDBusyLoop+0x1a>
	_delay_us(0.5);		//tAS
	
	do
	{

		SET_E();
     a68:	88 b1       	in	r24, 0x08	; 8
     a6a:	80 68       	ori	r24, 0x80	; 128
     a6c:	88 b9       	out	0x08, r24	; 8
     a6e:	92 e0       	ldi	r25, 0x02	; 2
     a70:	9a 95       	dec	r25
     a72:	f1 f7       	brne	.-4      	; 0xa70 <LCDBusyLoop+0x22>
     a74:	00 c0       	rjmp	.+0      	; 0xa76 <LCDBusyLoop+0x28>

		//Wait tDA for data to become available
		_delay_us(0.5);
		
		status=LCD_DATA_PIN;
     a76:	86 b1       	in	r24, 0x06	; 6
		status=status<<4;
     a78:	82 95       	swap	r24
     a7a:	80 7f       	andi	r24, 0xF0	; 240
     a7c:	92 e0       	ldi	r25, 0x02	; 2
     a7e:	9a 95       	dec	r25
     a80:	f1 f7       	brne	.-4      	; 0xa7e <LCDBusyLoop+0x30>
     a82:	00 c0       	rjmp	.+0      	; 0xa84 <LCDBusyLoop+0x36>

		_delay_us(0.5);
		
		//Pull E low
		CLEAR_E();
     a84:	98 b1       	in	r25, 0x08	; 8
     a86:	9f 77       	andi	r25, 0x7F	; 127
     a88:	98 b9       	out	0x08, r25	; 8
     a8a:	95 e0       	ldi	r25, 0x05	; 5
     a8c:	9a 95       	dec	r25
     a8e:	f1 f7       	brne	.-4      	; 0xa8c <LCDBusyLoop+0x3e>
     a90:	00 00       	nop
		_delay_us(1);	//tEL
		
		SET_E();
     a92:	98 b1       	in	r25, 0x08	; 8
     a94:	90 68       	ori	r25, 0x80	; 128
     a96:	98 b9       	out	0x08, r25	; 8
     a98:	92 e0       	ldi	r25, 0x02	; 2
     a9a:	9a 95       	dec	r25
     a9c:	f1 f7       	brne	.-4      	; 0xa9a <LCDBusyLoop+0x4c>
     a9e:	00 c0       	rjmp	.+0      	; 0xaa0 <LCDBusyLoop+0x52>
		_delay_us(0.5);
		
		temp=LCD_DATA_PIN;
     aa0:	96 b1       	in	r25, 0x06	; 6
		temp&=0x0F;

		status=status|temp;

		busy=status & 0b10000000;
     aa2:	80 78       	andi	r24, 0x80	; 128
     aa4:	92 e0       	ldi	r25, 0x02	; 2
     aa6:	9a 95       	dec	r25
     aa8:	f1 f7       	brne	.-4      	; 0xaa6 <LCDBusyLoop+0x58>
     aaa:	00 c0       	rjmp	.+0      	; 0xaac <LCDBusyLoop+0x5e>

		_delay_us(0.5);
		
		CLEAR_E();
     aac:	98 b1       	in	r25, 0x08	; 8
     aae:	9f 77       	andi	r25, 0x7F	; 127
     ab0:	98 b9       	out	0x08, r25	; 8
     ab2:	95 e0       	ldi	r25, 0x05	; 5
     ab4:	9a 95       	dec	r25
     ab6:	f1 f7       	brne	.-4      	; 0xab4 <LCDBusyLoop+0x66>
     ab8:	00 00       	nop
		_delay_us(1);	//tEL
		
	}while(busy);
     aba:	81 11       	cpse	r24, r1
     abc:	d5 cf       	rjmp	.-86     	; 0xa68 <LCDBusyLoop+0x1a>

	CLEAR_RW();		//write mode
     abe:	88 b1       	in	r24, 0x08	; 8
     ac0:	8f 7d       	andi	r24, 0xDF	; 223
     ac2:	88 b9       	out	0x08, r24	; 8
	//Change Port to output
	LCD_DATA_DDR|=0x0F;
     ac4:	87 b1       	in	r24, 0x07	; 7
     ac6:	8f 60       	ori	r24, 0x0F	; 15
     ac8:	87 b9       	out	0x07, r24	; 7
     aca:	08 95       	ret

00000acc <LCDByte>:
//NOTE: THIS FUNCTION RETURS ONLY WHEN LCD HAS PROCESSED THE COMMAND

uint8_t hn,ln;			//Nibbles
uint8_t temp;

hn=c>>4;
     acc:	28 2f       	mov	r18, r24
     ace:	22 95       	swap	r18
     ad0:	2f 70       	andi	r18, 0x0F	; 15
ln=(c & 0x0F);
     ad2:	8f 70       	andi	r24, 0x0F	; 15

if(isdata==0)
     ad4:	61 11       	cpse	r22, r1
     ad6:	04 c0       	rjmp	.+8      	; 0xae0 <LCDByte+0x14>
	CLEAR_RS();
     ad8:	98 b1       	in	r25, 0x08	; 8
     ada:	9f 7b       	andi	r25, 0xBF	; 191
     adc:	98 b9       	out	0x08, r25	; 8
     ade:	03 c0       	rjmp	.+6      	; 0xae6 <LCDByte+0x1a>
else
	SET_RS();
     ae0:	98 b1       	in	r25, 0x08	; 8
     ae2:	90 64       	ori	r25, 0x40	; 64
     ae4:	98 b9       	out	0x08, r25	; 8
     ae6:	92 e0       	ldi	r25, 0x02	; 2
     ae8:	9a 95       	dec	r25
     aea:	f1 f7       	brne	.-4      	; 0xae8 <LCDByte+0x1c>
     aec:	00 c0       	rjmp	.+0      	; 0xaee <LCDByte+0x22>

_delay_us(0.500);		//tAS


SET_E();
     aee:	98 b1       	in	r25, 0x08	; 8
     af0:	90 68       	ori	r25, 0x80	; 128
     af2:	98 b9       	out	0x08, r25	; 8

//Send high nibble

temp=(LCD_DATA_PORT & 0XF0)|(hn);
     af4:	98 b1       	in	r25, 0x08	; 8
     af6:	90 7f       	andi	r25, 0xF0	; 240
     af8:	92 2b       	or	r25, r18
LCD_DATA_PORT=temp;
     afa:	98 b9       	out	0x08, r25	; 8
     afc:	95 e0       	ldi	r25, 0x05	; 5
     afe:	9a 95       	dec	r25
     b00:	f1 f7       	brne	.-4      	; 0xafe <LCDByte+0x32>
     b02:	00 00       	nop
_delay_us(1);			//tEH


//Now data lines are stable pull E low for transmission

CLEAR_E();
     b04:	98 b1       	in	r25, 0x08	; 8
     b06:	9f 77       	andi	r25, 0x7F	; 127
     b08:	98 b9       	out	0x08, r25	; 8
     b0a:	95 e0       	ldi	r25, 0x05	; 5
     b0c:	9a 95       	dec	r25
     b0e:	f1 f7       	brne	.-4      	; 0xb0c <LCDByte+0x40>
     b10:	00 00       	nop

_delay_us(1);

//Send the lower nibble
SET_E();
     b12:	98 b1       	in	r25, 0x08	; 8
     b14:	90 68       	ori	r25, 0x80	; 128
     b16:	98 b9       	out	0x08, r25	; 8

temp=(LCD_DATA_PORT & 0XF0)|(ln);
     b18:	98 b1       	in	r25, 0x08	; 8
     b1a:	90 7f       	andi	r25, 0xF0	; 240
     b1c:	89 2b       	or	r24, r25

LCD_DATA_PORT=temp;
     b1e:	88 b9       	out	0x08, r24	; 8
     b20:	85 e0       	ldi	r24, 0x05	; 5
     b22:	8a 95       	dec	r24
     b24:	f1 f7       	brne	.-4      	; 0xb22 <LCDByte+0x56>
     b26:	00 00       	nop
_delay_us(1);			//tEH
						//Do not wait too long, 1 us is good

//SEND

CLEAR_E();
     b28:	88 b1       	in	r24, 0x08	; 8
     b2a:	8f 77       	andi	r24, 0x7F	; 127
     b2c:	88 b9       	out	0x08, r24	; 8
     b2e:	95 e0       	ldi	r25, 0x05	; 5
     b30:	9a 95       	dec	r25
     b32:	f1 f7       	brne	.-4      	; 0xb30 <LCDByte+0x64>
     b34:	00 00       	nop

_delay_us(1);			//tEL

LCDBusyLoop();
     b36:	8b cf       	rjmp	.-234    	; 0xa4e <LCDBusyLoop>
     b38:	08 95       	ret

00000b3a <InitLCD>:
	LCD_DATA_DDR|=0x0F;

}

void InitLCD(uint8_t style)
{
     b3a:	cf 93       	push	r28
     b3c:	c8 2f       	mov	r28, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     b3e:	2f ef       	ldi	r18, 0xFF	; 255
     b40:	86 e7       	ldi	r24, 0x76	; 118
     b42:	91 e0       	ldi	r25, 0x01	; 1
     b44:	21 50       	subi	r18, 0x01	; 1
     b46:	80 40       	sbci	r24, 0x00	; 0
     b48:	90 40       	sbci	r25, 0x00	; 0
     b4a:	e1 f7       	brne	.-8      	; 0xb44 <InitLCD+0xa>
     b4c:	00 c0       	rjmp	.+0      	; 0xb4e <InitLCD+0x14>
     b4e:	00 00       	nop
	
	//After power on Wait for LCD to Initialize
	_delay_ms(30);
		
	//Set IO Ports
	LCD_DATA_DDR|=(0x0F);
     b50:	87 b1       	in	r24, 0x07	; 7
     b52:	8f 60       	ori	r24, 0x0F	; 15
     b54:	87 b9       	out	0x07, r24	; 7
	LCD_E_DDR|=(1<<LCD_E_POS);
     b56:	87 b1       	in	r24, 0x07	; 7
     b58:	80 68       	ori	r24, 0x80	; 128
     b5a:	87 b9       	out	0x07, r24	; 7
	LCD_RS_DDR|=(1<<LCD_RS_POS);
     b5c:	87 b1       	in	r24, 0x07	; 7
     b5e:	80 64       	ori	r24, 0x40	; 64
     b60:	87 b9       	out	0x07, r24	; 7
	LCD_RW_DDR|=(1<<LCD_RW_POS);
     b62:	87 b1       	in	r24, 0x07	; 7
     b64:	80 62       	ori	r24, 0x20	; 32
     b66:	87 b9       	out	0x07, r24	; 7

	LCD_DATA_PORT&=0XF0;
     b68:	88 b1       	in	r24, 0x08	; 8
     b6a:	80 7f       	andi	r24, 0xF0	; 240
     b6c:	88 b9       	out	0x08, r24	; 8
	CLEAR_E();
     b6e:	88 b1       	in	r24, 0x08	; 8
     b70:	8f 77       	andi	r24, 0x7F	; 127
     b72:	88 b9       	out	0x08, r24	; 8
	CLEAR_RW();
     b74:	88 b1       	in	r24, 0x08	; 8
     b76:	8f 7d       	andi	r24, 0xDF	; 223
     b78:	88 b9       	out	0x08, r24	; 8
	CLEAR_RS();
     b7a:	88 b1       	in	r24, 0x08	; 8
     b7c:	8f 7b       	andi	r24, 0xBF	; 191
     b7e:	88 b9       	out	0x08, r24	; 8
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     b80:	00 c0       	rjmp	.+0      	; 0xb82 <InitLCD+0x48>
     b82:	00 c0       	rjmp	.+0      	; 0xb84 <InitLCD+0x4a>
     b84:	00 00       	nop

	//Set 4-bit mode
	_delay_us(0.3);	//tAS
	
	SET_E();
     b86:	88 b1       	in	r24, 0x08	; 8
     b88:	80 68       	ori	r24, 0x80	; 128
     b8a:	88 b9       	out	0x08, r24	; 8
	LCD_DATA_PORT|=(0b00000010); //[B] To transfer 0b00100000 i was using LCD_DATA_PORT|=0b00100000
     b8c:	88 b1       	in	r24, 0x08	; 8
     b8e:	82 60       	ori	r24, 0x02	; 2
     b90:	88 b9       	out	0x08, r24	; 8
     b92:	25 e0       	ldi	r18, 0x05	; 5
     b94:	2a 95       	dec	r18
     b96:	f1 f7       	brne	.-4      	; 0xb94 <InitLCD+0x5a>
     b98:	00 00       	nop
	_delay_us(1);
	
	CLEAR_E();
     b9a:	88 b1       	in	r24, 0x08	; 8
     b9c:	8f 77       	andi	r24, 0x7F	; 127
     b9e:	88 b9       	out	0x08, r24	; 8
     ba0:	85 e0       	ldi	r24, 0x05	; 5
     ba2:	8a 95       	dec	r24
     ba4:	f1 f7       	brne	.-4      	; 0xba2 <InitLCD+0x68>
     ba6:	00 00       	nop
	_delay_us(1);
		
	//Wait for LCD to execute the Functionset Command
	LCDBusyLoop();                                    //[B] Forgot this delay
     ba8:	52 df       	rcall	.-348    	; 0xa4e <LCDBusyLoop>

	//Now the LCD is in 4-bit mode

	LCDCmd(0b00001100|style);	//Display On
     baa:	60 e0       	ldi	r22, 0x00	; 0
     bac:	8c 2f       	mov	r24, r28
     bae:	8c 60       	ori	r24, 0x0C	; 12
     bb0:	8d df       	rcall	.-230    	; 0xacc <LCDByte>
	LCDCmd(0b00101000);			//function set 4-bit,2 line 5x7 dot format
     bb2:	60 e0       	ldi	r22, 0x00	; 0
     bb4:	88 e2       	ldi	r24, 0x28	; 40
     bb6:	8a df       	rcall	.-236    	; 0xacc <LCDByte>
}
     bb8:	cf 91       	pop	r28
     bba:	08 95       	ret

00000bbc <LCDWriteString>:
void LCDWriteString(const char *msg)
{
     bbc:	cf 93       	push	r28
     bbe:	df 93       	push	r29
     bc0:	ec 01       	movw	r28, r24
	Arguments:
	msg: a null terminated string to print


	*****************************************************************/
 while(*msg!='\0')
     bc2:	03 c0       	rjmp	.+6      	; 0xbca <LCDWriteString+0xe>
 {
	LCDData(*msg);
     bc4:	61 e0       	ldi	r22, 0x01	; 1
     bc6:	82 df       	rcall	.-252    	; 0xacc <LCDByte>
	msg++;
     bc8:	21 96       	adiw	r28, 0x01	; 1
	Arguments:
	msg: a null terminated string to print


	*****************************************************************/
 while(*msg!='\0')
     bca:	88 81       	ld	r24, Y
     bcc:	81 11       	cpse	r24, r1
     bce:	fa cf       	rjmp	.-12     	; 0xbc4 <LCDWriteString+0x8>
 {
	LCDData(*msg);
	msg++;
 }
}
     bd0:	df 91       	pop	r29
     bd2:	cf 91       	pop	r28
     bd4:	08 95       	ret

00000bd6 <LCDWriteInt>:

void LCDWriteInt(int val,unsigned int field_length)
{
     bd6:	ef 92       	push	r14
     bd8:	ff 92       	push	r15
     bda:	0f 93       	push	r16
     bdc:	1f 93       	push	r17
     bde:	cf 93       	push	r28
     be0:	df 93       	push	r29
     be2:	00 d0       	rcall	.+0      	; 0xbe4 <LCDWriteInt+0xe>
     be4:	1f 92       	push	r1
     be6:	1f 92       	push	r1
     be8:	cd b7       	in	r28, 0x3d	; 61
     bea:	de b7       	in	r29, 0x3e	; 62
     bec:	7b 01       	movw	r14, r22
	2)unsigned int field_length :total length of field in which the value is printed
	must be between 1-5 if it is -1 the field length is no of digits in the val

	****************************************************************/

	char str[5]={0,0,0,0,0};
     bee:	fe 01       	movw	r30, r28
     bf0:	31 96       	adiw	r30, 0x01	; 1
     bf2:	25 e0       	ldi	r18, 0x05	; 5
     bf4:	df 01       	movw	r26, r30
     bf6:	1d 92       	st	X+, r1
     bf8:	2a 95       	dec	r18
     bfa:	e9 f7       	brne	.-6      	; 0xbf6 <LCDWriteInt+0x20>
	int i=4,j=0;
     bfc:	24 e0       	ldi	r18, 0x04	; 4
     bfe:	30 e0       	ldi	r19, 0x00	; 0
	while(val)
     c00:	0e c0       	rjmp	.+28     	; 0xc1e <LCDWriteInt+0x48>
	{
	str[i]=val%10;
     c02:	6a e0       	ldi	r22, 0x0A	; 10
     c04:	70 e0       	ldi	r23, 0x00	; 0
     c06:	fc d6       	rcall	.+3576   	; 0x1a00 <__divmodhi4>
     c08:	e1 e0       	ldi	r30, 0x01	; 1
     c0a:	f0 e0       	ldi	r31, 0x00	; 0
     c0c:	ec 0f       	add	r30, r28
     c0e:	fd 1f       	adc	r31, r29
     c10:	e2 0f       	add	r30, r18
     c12:	f3 1f       	adc	r31, r19
     c14:	80 83       	st	Z, r24
	val=val/10;
     c16:	86 2f       	mov	r24, r22
     c18:	97 2f       	mov	r25, r23
	i--;
     c1a:	21 50       	subi	r18, 0x01	; 1
     c1c:	31 09       	sbc	r19, r1

	****************************************************************/

	char str[5]={0,0,0,0,0};
	int i=4,j=0;
	while(val)
     c1e:	00 97       	sbiw	r24, 0x00	; 0
     c20:	81 f7       	brne	.-32     	; 0xc02 <LCDWriteInt+0x2c>
	{
	str[i]=val%10;
	val=val/10;
	i--;
	}
	if(field_length==-1)
     c22:	bf ef       	ldi	r27, 0xFF	; 255
     c24:	eb 16       	cp	r14, r27
     c26:	fb 06       	cpc	r15, r27
     c28:	81 f4       	brne	.+32     	; 0xc4a <LCDWriteInt+0x74>
     c2a:	03 c0       	rjmp	.+6      	; 0xc32 <LCDWriteInt+0x5c>
		while(str[j]==0) j++;
     c2c:	0f 5f       	subi	r16, 0xFF	; 255
     c2e:	1f 4f       	sbci	r17, 0xFF	; 255
     c30:	02 c0       	rjmp	.+4      	; 0xc36 <LCDWriteInt+0x60>
     c32:	00 e0       	ldi	r16, 0x00	; 0
     c34:	10 e0       	ldi	r17, 0x00	; 0
     c36:	e1 e0       	ldi	r30, 0x01	; 1
     c38:	f0 e0       	ldi	r31, 0x00	; 0
     c3a:	ec 0f       	add	r30, r28
     c3c:	fd 1f       	adc	r31, r29
     c3e:	e0 0f       	add	r30, r16
     c40:	f1 1f       	adc	r31, r17
     c42:	20 81       	ld	r18, Z
     c44:	22 23       	and	r18, r18
     c46:	91 f3       	breq	.-28     	; 0xc2c <LCDWriteInt+0x56>
     c48:	04 c0       	rjmp	.+8      	; 0xc52 <LCDWriteInt+0x7c>
	else
		j=5-field_length;
     c4a:	05 e0       	ldi	r16, 0x05	; 5
     c4c:	10 e0       	ldi	r17, 0x00	; 0
     c4e:	0e 19       	sub	r16, r14
     c50:	1f 09       	sbc	r17, r15

	if(val<0) LCDData('-');
     c52:	99 23       	and	r25, r25
     c54:	84 f4       	brge	.+32     	; 0xc76 <LCDWriteInt+0xa0>
     c56:	61 e0       	ldi	r22, 0x01	; 1
     c58:	8d e2       	ldi	r24, 0x2D	; 45
     c5a:	38 df       	rcall	.-400    	; 0xacc <LCDByte>
     c5c:	0c c0       	rjmp	.+24     	; 0xc76 <LCDWriteInt+0xa0>
	for(i=j;i<5;i++)
	{
	LCDData(48+str[i]);
     c5e:	e1 e0       	ldi	r30, 0x01	; 1
     c60:	f0 e0       	ldi	r31, 0x00	; 0
     c62:	ec 0f       	add	r30, r28
     c64:	fd 1f       	adc	r31, r29
     c66:	e0 0f       	add	r30, r16
     c68:	f1 1f       	adc	r31, r17
     c6a:	80 81       	ld	r24, Z
     c6c:	61 e0       	ldi	r22, 0x01	; 1
     c6e:	80 5d       	subi	r24, 0xD0	; 208
     c70:	2d df       	rcall	.-422    	; 0xacc <LCDByte>
		while(str[j]==0) j++;
	else
		j=5-field_length;

	if(val<0) LCDData('-');
	for(i=j;i<5;i++)
     c72:	0f 5f       	subi	r16, 0xFF	; 255
     c74:	1f 4f       	sbci	r17, 0xFF	; 255
     c76:	05 30       	cpi	r16, 0x05	; 5
     c78:	11 05       	cpc	r17, r1
     c7a:	8c f3       	brlt	.-30     	; 0xc5e <LCDWriteInt+0x88>
	{
	LCDData(48+str[i]);
	}
}
     c7c:	0f 90       	pop	r0
     c7e:	0f 90       	pop	r0
     c80:	0f 90       	pop	r0
     c82:	0f 90       	pop	r0
     c84:	0f 90       	pop	r0
     c86:	df 91       	pop	r29
     c88:	cf 91       	pop	r28
     c8a:	1f 91       	pop	r17
     c8c:	0f 91       	pop	r16
     c8e:	ff 90       	pop	r15
     c90:	ef 90       	pop	r14
     c92:	08 95       	ret

00000c94 <LCDGotoXY>:
void LCDGotoXY(uint8_t x,uint8_t y)
{
 if(x<40)
     c94:	88 32       	cpi	r24, 0x28	; 40
     c96:	28 f4       	brcc	.+10     	; 0xca2 <LCDGotoXY+0xe>
 {
  if(y) x|=0b01000000;
     c98:	61 11       	cpse	r22, r1
     c9a:	80 64       	ori	r24, 0x40	; 64
  x|=0b10000000;
  LCDCmd(x);
     c9c:	60 e0       	ldi	r22, 0x00	; 0
     c9e:	80 68       	ori	r24, 0x80	; 128
     ca0:	15 cf       	rjmp	.-470    	; 0xacc <LCDByte>
     ca2:	08 95       	ret

00000ca4 <main>:


int main(int argc, char *argv[]){
//INITIALIZATION	
	//Limit Clock to 8MHz
	CLKPR = 0x80;
     ca4:	e1 e6       	ldi	r30, 0x61	; 97
     ca6:	f0 e0       	ldi	r31, 0x00	; 0
     ca8:	80 e8       	ldi	r24, 0x80	; 128
     caa:	80 83       	st	Z, r24
	CLKPR = 0x01;
     cac:	81 e0       	ldi	r24, 0x01	; 1
     cae:	80 83       	st	Z, r24

	
	cli();//Disable Interrupts
     cb0:	f8 94       	cli
	
	//GPIO setup
	DDRA = 0xFF; //OUTPUT for stepper
     cb2:	8f ef       	ldi	r24, 0xFF	; 255
     cb4:	81 b9       	out	0x01, r24	; 1
	DDRB = 0xFF; //OUTPUT for motor
     cb6:	84 b9       	out	0x04, r24	; 4
	DDRC = 0xFF; //OUTPUT for LCD
     cb8:	87 b9       	out	0x07, r24	; 7
	DDRD = 0x00;//INPUT for EX, OR, HE, PAUSE
     cba:	1a b8       	out	0x0a, r1	; 10
	DDRJ &= ~_BV(PINJ0); //INPUT
     cbc:	e4 e0       	ldi	r30, 0x04	; 4
     cbe:	f1 e0       	ldi	r31, 0x01	; 1
     cc0:	80 81       	ld	r24, Z
     cc2:	8e 7f       	andi	r24, 0xFE	; 254
     cc4:	80 83       	st	Z, r24
	
	//EXT INTERRUPTS
	EICRA |= _BV(ISC01);//PAUSE
     cc6:	e9 e6       	ldi	r30, 0x69	; 105
     cc8:	f0 e0       	ldi	r31, 0x00	; 0
     cca:	80 81       	ld	r24, Z
     ccc:	82 60       	ori	r24, 0x02	; 2
     cce:	80 83       	st	Z, r24
	EICRA |= _BV(ISC11) |_BV(ISC10);//OR
     cd0:	80 81       	ld	r24, Z
     cd2:	8c 60       	ori	r24, 0x0C	; 12
     cd4:	80 83       	st	Z, r24
	EICRA |= _BV(ISC21);//EX
     cd6:	80 81       	ld	r24, Z
     cd8:	80 62       	ori	r24, 0x20	; 32
     cda:	80 83       	st	Z, r24
	EICRA |= _BV(ISC31) | _BV(ISC30);//HE
     cdc:	80 81       	ld	r24, Z
     cde:	80 6c       	ori	r24, 0xC0	; 192
     ce0:	80 83       	st	Z, r24
	
	PCICR |= _BV(PCIE1);//Enable PCINT1
     ce2:	e8 e6       	ldi	r30, 0x68	; 104
     ce4:	f0 e0       	ldi	r31, 0x00	; 0
     ce6:	80 81       	ld	r24, Z
     ce8:	82 60       	ori	r24, 0x02	; 2
     cea:	80 83       	st	Z, r24
	PCMSK1 |= _BV(PCINT9);//RAMPDOWN
     cec:	ac e6       	ldi	r26, 0x6C	; 108
     cee:	b0 e0       	ldi	r27, 0x00	; 0
     cf0:	8c 91       	ld	r24, X
     cf2:	82 60       	ori	r24, 0x02	; 2
     cf4:	8c 93       	st	X, r24
	
	PCICR |= _BV(PCIE0);//Enable PCINT 0
     cf6:	80 81       	ld	r24, Z
     cf8:	81 60       	ori	r24, 0x01	; 1
     cfa:	80 83       	st	Z, r24
	PCMSK0 |= _BV(PCINT4);//Motor Controller
     cfc:	eb e6       	ldi	r30, 0x6B	; 107
     cfe:	f0 e0       	ldi	r31, 0x00	; 0
     d00:	80 81       	ld	r24, Z
     d02:	80 61       	ori	r24, 0x10	; 16
     d04:	80 83       	st	Z, r24


	ADC_Init();
     d06:	77 dc       	rcall	.-1810   	; 0x5f6 <ADC_Init>
	mTimer_init();
     d08:	1f dd       	rcall	.-1474   	; 0x748 <mTimer_init>
	stepTimer_init();
     d0a:	83 d5       	rcall	.+2822   	; 0x1812 <stepTimer_init>
	InitLCD(LS_BLINK|LS_ULINE);
     d0c:	83 e0       	ldi	r24, 0x03	; 3
     d0e:	15 df       	rcall	.-470    	; 0xb3a <InitLCD>
	LCDClear();
     d10:	60 e0       	ldi	r22, 0x00	; 0
     d12:	81 e0       	ldi	r24, 0x01	; 1
     d14:	db de       	rcall	.-586    	; 0xacc <LCDByte>
	EIMSK |= 0x08;//Enable HE
     d16:	8d b3       	in	r24, 0x1d	; 29
     d18:	88 60       	ori	r24, 0x08	; 8
     d1a:	8d bb       	out	0x1d, r24	; 29
	sei();// Enable global interrupts
     d1c:	78 94       	sei
	// Calculate the stepper acceleration profile and calibrate position
	stepCalibrate();
     d1e:	3a d6       	rcall	.+3188   	; 0x1994 <stepCalibrate>
     d20:	8d b3       	in	r24, 0x1d	; 29
	EIMSK |= 0x07;//Enable OR, EX, and PAUSE
     d22:	87 60       	ori	r24, 0x07	; 7
     d24:	8d bb       	out	0x1d, r24	; 29
	EIMSK &= ~(0x08);//Disable HE
     d26:	8d b3       	in	r24, 0x1d	; 29
     d28:	87 7f       	andi	r24, 0xF7	; 247
	
	//Initialize the belt motor PWM and pins
	Motor_init();
     d2a:	8d bb       	out	0x1d, r24	; 29
	

	//reset counters
	countPart=0;
     d2c:	b3 db       	rcall	.-2202   	; 0x494 <Motor_init>
     d2e:	10 92 65 02 	sts	0x0265, r1	; 0x800265 <countPart>
	countSort = 0;
     d32:	10 92 64 02 	sts	0x0264, r1	; 0x800264 <countSort>
	startMotor();//Start Belt motor
     d36:	d8 db       	rcall	.-2128   	; 0x4e8 <startMotor>
	runTimerStart();//Start System Timer
     d38:	16 dd       	rcall	.-1492   	; 0x766 <runTimerStart>
     d3a:	80 91 0c 02 	lds	r24, 0x020C	; 0x80020c <ENABLE>

STANDBY://Display the system status and handle button push events

	while (1)
	{				
		if(ENABLE)
     d3e:	88 23       	and	r24, r24
     d40:	b1 f1       	breq	.+108    	; 0xdae <main+0x10a>
     d42:	80 91 60 02 	lds	r24, 0x0260	; 0x800260 <runTime_d>
		{//if the system is enabled
			if((runTime_d-refreshTime)>REFRESH_PERIOD)
     d46:	90 91 61 02 	lds	r25, 0x0261	; 0x800261 <runTime_d+0x1>
     d4a:	20 91 5e 02 	lds	r18, 0x025E	; 0x80025e <refreshTime>
     d4e:	30 91 5f 02 	lds	r19, 0x025F	; 0x80025f <refreshTime+0x1>
     d52:	82 1b       	sub	r24, r18
     d54:	93 0b       	sbc	r25, r19
     d56:	c3 97       	sbiw	r24, 0x33	; 51
     d58:	48 f0       	brcs	.+18     	; 0xd6c <main+0xc8>
			{//if LCD needs to be updated
				dispStatus();//display system information
     d5a:	94 dd       	rcall	.-1240   	; 0x884 <dispStatus>
     d5c:	80 91 60 02 	lds	r24, 0x0260	; 0x800260 <runTime_d>
				refreshTime = runTime_d;//control refresh rate of LCD
     d60:	90 91 61 02 	lds	r25, 0x0261	; 0x800261 <runTime_d+0x1>
     d64:	90 93 5f 02 	sts	0x025F, r25	; 0x80025f <refreshTime+0x1>
     d68:	80 93 5e 02 	sts	0x025E, r24	; 0x80025e <refreshTime>
     d6c:	80 91 70 02 	lds	r24, 0x0270	; 0x800270 <RAMPDOWN>
		{//else go to disabled state
			goto DISABLE;
		}


		if(RAMPDOWN)
     d70:	88 23       	and	r24, r24
     d72:	19 f3       	breq	.-58     	; 0xd3a <main+0x96>
     d74:	90 91 64 02 	lds	r25, 0x0264	; 0x800264 <countSort>
		{//if RAMPDOWN button is pushed
			if(countSort != countPart)
     d78:	80 91 65 02 	lds	r24, 0x0265	; 0x800265 <countPart>
     d7c:	98 17       	cp	r25, r24
     d7e:	49 f0       	breq	.+18     	; 0xd92 <main+0xee>
     d80:	80 91 60 02 	lds	r24, 0x0260	; 0x800260 <runTime_d>
			{//if there are parts which need sorting
				rampTime_d = runTime_d;//reset RAMPDOWN timer
     d84:	90 91 61 02 	lds	r25, 0x0261	; 0x800261 <runTime_d+0x1>
     d88:	90 93 5d 02 	sts	0x025D, r25	; 0x80025d <rampTime_d+0x1>
     d8c:	80 93 5c 02 	sts	0x025C, r24	; 0x80025c <rampTime_d>
     d90:	d4 cf       	rjmp	.-88     	; 0xd3a <main+0x96>
     d92:	80 91 60 02 	lds	r24, 0x0260	; 0x800260 <runTime_d>
				
			}else if((runTime_d-rampTime_d)>RAMPDOWN_DELAY)
     d96:	90 91 61 02 	lds	r25, 0x0261	; 0x800261 <runTime_d+0x1>
     d9a:	20 91 5c 02 	lds	r18, 0x025C	; 0x80025c <rampTime_d>
     d9e:	30 91 5d 02 	lds	r19, 0x025D	; 0x80025d <rampTime_d+0x1>
     da2:	82 1b       	sub	r24, r18
     da4:	93 0b       	sbc	r25, r19
     da6:	81 3d       	cpi	r24, 0xD1	; 209
     da8:	97 40       	sbci	r25, 0x07	; 7
	}//while ENABLE
	
	
	
DISABLE:// when the ENABLE is reset by ISR(INT0_vect)
	brakeMotor();//stop the belt
     daa:	38 f2       	brcs	.-114    	; 0xd3a <main+0x96>
     dac:	2a c0       	rjmp	.+84     	; 0xe02 <main+0x15e>
	while((PIND & 0x01) == 0x00);//wait for PAUSE button to be released
     dae:	61 db       	rcall	.-2366   	; 0x472 <brakeMotor>
     db0:	48 9b       	sbis	0x09, 0	; 9
	stepStop();//stop the stepper motor
     db2:	fe cf       	rjmp	.-4      	; 0xdb0 <main+0x10c>
     db4:	5a d5       	rcall	.+2740   	; 0x186a <stepStop>
	runTimerStop();//stop the run timer
     db6:	f2 dc       	rcall	.-1564   	; 0x79c <runTimerStop>
     db8:	cd b3       	in	r28, 0x1d	; 29
	uint8_t INTState = EIMSK; //save current interrupt state
	
	//Disable all interrupts except PAUSE button
	EIMSK = 0x01;
     dba:	81 e0       	ldi	r24, 0x01	; 1
	PCMSK1 &= ~_BV(PCINT9);
     dbc:	8d bb       	out	0x1d, r24	; 29
     dbe:	ec e6       	ldi	r30, 0x6C	; 108
     dc0:	f0 e0       	ldi	r31, 0x00	; 0
     dc2:	80 81       	ld	r24, Z
     dc4:	8d 7f       	andi	r24, 0xFD	; 253
	PCMSK0 &= ~_BV(PCINT4);
     dc6:	80 83       	st	Z, r24
     dc8:	eb e6       	ldi	r30, 0x6B	; 107
     dca:	f0 e0       	ldi	r31, 0x00	; 0
     dcc:	80 81       	ld	r24, Z
     dce:	8f 7e       	andi	r24, 0xEF	; 239
	
	brakeMotor();//insure motor is stopped (for edge case)
     dd0:	80 83       	st	Z, r24
     dd2:	4f db       	rcall	.-2402   	; 0x472 <brakeMotor>
	stepRes();//Reset the stepper acceleration
     dd4:	8c d4       	rcall	.+2328   	; 0x16ee <stepRes>
     dd6:	e2 dd       	rcall	.-1084   	; 0x99c <dispPause>
	dispPause();//Display pause information
     dd8:	80 91 0c 02 	lds	r24, 0x020C	; 0x80020c <ENABLE>
	
	//Wait for PAUSE button to be pushed again
	while(!ENABLE);
     ddc:	88 23       	and	r24, r24
     dde:	e1 f3       	breq	.-8      	; 0xdd8 <main+0x134>
	while((PIND & 0x01) == 0x00);//wait for PAUSE button release
     de0:	48 9b       	sbis	0x09, 0	; 9
     de2:	fe cf       	rjmp	.-4      	; 0xde0 <main+0x13c>
	
	//return interrupts to previous state
	EIMSK = INTState;
     de4:	cd bb       	out	0x1d, r28	; 29
	PCMSK1 |= _BV(PCINT9);
     de6:	ec e6       	ldi	r30, 0x6C	; 108
     de8:	f0 e0       	ldi	r31, 0x00	; 0
     dea:	80 81       	ld	r24, Z
     dec:	82 60       	ori	r24, 0x02	; 2
	PCMSK0 |= _BV(PCINT4);
     dee:	80 83       	st	Z, r24
     df0:	eb e6       	ldi	r30, 0x6B	; 107
     df2:	f0 e0       	ldi	r31, 0x00	; 0
     df4:	80 81       	ld	r24, Z
     df6:	80 61       	ori	r24, 0x10	; 16
	runTimerResume();//start system timer
     df8:	80 83       	st	Z, r24
     dfa:	d6 dc       	rcall	.-1620   	; 0x7a8 <runTimerResume>
	stepStart();//start stepper
     dfc:	1f d5       	rcall	.+2622   	; 0x183c <stepStart>
     dfe:	9a db       	rcall	.-2252   	; 0x534 <runMotor>
	runMotor();//start motor
     e00:	9c cf       	rjmp	.-200    	; 0xd3a <main+0x96>
     e02:	f8 94       	cli
	
goto STANDBY;//return to STANDBY mode
     e04:	15 b8       	out	0x05, r1	; 5
	
	
SHUTDOWN://When RAMPDOWN has been pushed and no part is on belt
	cli();//disable all interrupts
     e06:	12 b8       	out	0x02, r1	; 2
	PORTB = 0x00;//disable belt motor
     e08:	fa dc       	rcall	.-1548   	; 0x7fe <dispComplete>
	PORTA = 0x00;//disable stepper motor
     e0a:	ff cf       	rjmp	.-2      	; 0xe0a <main+0x166>

00000e0c <__vector_2>:
	dispComplete();//display complete information
     e0c:	1f 92       	push	r1
     e0e:	0f 92       	push	r0
     e10:	0f b6       	in	r0, 0x3f	; 63

RUNTIME ~500cc
                                                                  */
/************************************************************************/
ISR(INT1_vect)
{//OR has triggered falling or rising edge
     e12:	0f 92       	push	r0
     e14:	11 24       	eor	r1, r1
     e16:	0b b6       	in	r0, 0x3b	; 59
     e18:	0f 92       	push	r0
     e1a:	2f 93       	push	r18
     e1c:	3f 93       	push	r19
     e1e:	4f 93       	push	r20
     e20:	5f 93       	push	r21
     e22:	6f 93       	push	r22
     e24:	7f 93       	push	r23
     e26:	8f 93       	push	r24
     e28:	9f 93       	push	r25
     e2a:	af 93       	push	r26
     e2c:	bf 93       	push	r27
     e2e:	cf 93       	push	r28
     e30:	df 93       	push	r29
     e32:	ef 93       	push	r30
     e34:	ff 93       	push	r31
	if(ORFLAG)
     e36:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <ORFLAG>
     e3a:	88 23       	and	r24, r24
     e3c:	81 f1       	breq	.+96     	; 0xe9e <__vector_2+0x92>
	{//if Part is entering OR
		
	
		if(debounce(1, 1, NOISECHECK))
     e3e:	48 e0       	ldi	r20, 0x08	; 8
     e40:	50 e0       	ldi	r21, 0x00	; 0
     e42:	61 e0       	ldi	r22, 0x01	; 1
     e44:	81 e0       	ldi	r24, 0x01	; 1
     e46:	fe db       	rcall	.-2052   	; 0x644 <debounce>
     e48:	88 23       	and	r24, r24
     e4a:	09 f4       	brne	.+2      	; 0xe4e <__vector_2+0x42>
     e4c:	93 c0       	rjmp	.+294    	; 0xf74 <__vector_2+0x168>
		{//FILTER noise
			
			ORFLAG  = 0; //Part has entered OR
     e4e:	10 92 0b 02 	sts	0x020B, r1	; 0x80020b <ORFLAG>
			
			//set to falling edge
			EIMSK &= ~_BV(INT1);
     e52:	8d b3       	in	r24, 0x1d	; 29
     e54:	8d 7f       	andi	r24, 0xFD	; 253
     e56:	8d bb       	out	0x1d, r24	; 29
			EICRA &= ~_BV(ISC10);
     e58:	e9 e6       	ldi	r30, 0x69	; 105
     e5a:	f0 e0       	ldi	r31, 0x00	; 0
     e5c:	80 81       	ld	r24, Z
     e5e:	8b 7f       	andi	r24, 0xFB	; 251
     e60:	80 83       	st	Z, r24
			EIMSK |= _BV(INT1); 
     e62:	8d b3       	in	r24, 0x1d	; 29
     e64:	82 60       	ori	r24, 0x02	; 2
     e66:	8d bb       	out	0x1d, r24	; 29

			//reset adc variables
			countADC = 0;
     e68:	10 92 63 02 	sts	0x0263, r1	; 0x800263 <countADC+0x1>
     e6c:	10 92 62 02 	sts	0x0262, r1	; 0x800262 <countADC>
			adcPart = 1023;
     e70:	8f ef       	ldi	r24, 0xFF	; 255
     e72:	93 e0       	ldi	r25, 0x03	; 3
     e74:	90 93 0a 02 	sts	0x020A, r25	; 0x80020a <adcPart+0x1>
     e78:	80 93 09 02 	sts	0x0209, r24	; 0x800209 <adcPart>
		
			ADCSRA |=_BV(ADSC);//start first ADC conversion
     e7c:	ea e7       	ldi	r30, 0x7A	; 122
     e7e:	f0 e0       	ldi	r31, 0x00	; 0
     e80:	80 81       	ld	r24, Z
     e82:	80 64       	ori	r24, 0x40	; 64
     e84:	80 83       	st	Z, r24
			
			ORTime_s = runTime_d;//record time part entered
     e86:	80 91 60 02 	lds	r24, 0x0260	; 0x800260 <runTime_d>
     e8a:	90 91 61 02 	lds	r25, 0x0261	; 0x800261 <runTime_d+0x1>
     e8e:	90 93 5b 02 	sts	0x025B, r25	; 0x80025b <ORTime_s+0x1>
     e92:	80 93 5a 02 	sts	0x025A, r24	; 0x80025a <ORTime_s>
			EIFR |= _BV(INT1);//reset interrupt flag (for edge case)
     e96:	8c b3       	in	r24, 0x1c	; 28
     e98:	82 60       	ori	r24, 0x02	; 2
     e9a:	8c bb       	out	0x1c, r24	; 28
     e9c:	6b c0       	rjmp	.+214    	; 0xf74 <__vector_2+0x168>
		
	}else//!ORFLAG
	{//if Part is leaving OR
		

		if(debounce(1, 0, NOISECHECK) && ((runTime_d - ORTime_s) > PARTTIME))
     e9e:	48 e0       	ldi	r20, 0x08	; 8
     ea0:	50 e0       	ldi	r21, 0x00	; 0
     ea2:	60 e0       	ldi	r22, 0x00	; 0
     ea4:	81 e0       	ldi	r24, 0x01	; 1
     ea6:	ce db       	rcall	.-2148   	; 0x644 <debounce>
     ea8:	88 23       	and	r24, r24
     eaa:	09 f4       	brne	.+2      	; 0xeae <__vector_2+0xa2>
     eac:	63 c0       	rjmp	.+198    	; 0xf74 <__vector_2+0x168>
     eae:	80 91 60 02 	lds	r24, 0x0260	; 0x800260 <runTime_d>
     eb2:	90 91 61 02 	lds	r25, 0x0261	; 0x800261 <runTime_d+0x1>
     eb6:	20 91 5a 02 	lds	r18, 0x025A	; 0x80025a <ORTime_s>
     eba:	30 91 5b 02 	lds	r19, 0x025B	; 0x80025b <ORTime_s+0x1>
     ebe:	82 1b       	sub	r24, r18
     ec0:	93 0b       	sbc	r25, r19
     ec2:	06 97       	sbiw	r24, 0x06	; 6
     ec4:	08 f4       	brcc	.+2      	; 0xec8 <__vector_2+0xbc>
     ec6:	56 c0       	rjmp	.+172    	; 0xf74 <__vector_2+0x168>
		{//FILTER noise and double edge detection
			ORFLAG  = 1;//Part has cleared OR	
     ec8:	81 e0       	ldi	r24, 0x01	; 1
     eca:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <ORFLAG>
			
			//Turn on rising edge
			EIMSK &= ~_BV(INT1); 
     ece:	8d b3       	in	r24, 0x1d	; 29
     ed0:	8d 7f       	andi	r24, 0xFD	; 253
     ed2:	8d bb       	out	0x1d, r24	; 29
			EICRA |= _BV(ISC10);
     ed4:	e9 e6       	ldi	r30, 0x69	; 105
     ed6:	f0 e0       	ldi	r31, 0x00	; 0
     ed8:	80 81       	ld	r24, Z
     eda:	84 60       	ori	r24, 0x04	; 4
     edc:	80 83       	st	Z, r24
			EIMSK |= _BV(INT1); 
     ede:	8d b3       	in	r24, 0x1d	; 29
     ee0:	82 60       	ori	r24, 0x02	; 2
     ee2:	8d bb       	out	0x1d, r24	; 29

			adcDisp = adcPart;//set display ADC variable
     ee4:	80 91 09 02 	lds	r24, 0x0209	; 0x800209 <adcPart>
     ee8:	90 91 0a 02 	lds	r25, 0x020A	; 0x80020a <adcPart+0x1>
     eec:	90 93 06 02 	sts	0x0206, r25	; 0x800206 <adcDisp+0x1>
     ef0:	80 93 05 02 	sts	0x0205, r24	; 0x800205 <adcDisp>
			
			//FILTER bad reads from ADC
			if((adcPart<HI_Reflect) && countADC>50)
     ef4:	80 91 09 02 	lds	r24, 0x0209	; 0x800209 <adcPart>
     ef8:	90 91 0a 02 	lds	r25, 0x020A	; 0x80020a <adcPart+0x1>
     efc:	82 3f       	cpi	r24, 0xF2	; 242
     efe:	93 40       	sbci	r25, 0x03	; 3
     f00:	b0 f5       	brcc	.+108    	; 0xf6e <__vector_2+0x162>
     f02:	80 91 62 02 	lds	r24, 0x0262	; 0x800262 <countADC>
     f06:	90 91 63 02 	lds	r25, 0x0263	; 0x800263 <countADC+0x1>
     f0a:	c3 97       	sbiw	r24, 0x33	; 51
     f0c:	80 f1       	brcs	.+96     	; 0xf6e <__vector_2+0x162>
			{//if a reflect value was recorded and the adc got more than minimum reads
				Parts[countPart] = classify(adcPart);//classify the part and add to array
     f0e:	c0 91 65 02 	lds	r28, 0x0265	; 0x800265 <countPart>
     f12:	d0 e0       	ldi	r29, 0x00	; 0
     f14:	80 91 09 02 	lds	r24, 0x0209	; 0x800209 <adcPart>
     f18:	90 91 0a 02 	lds	r25, 0x020A	; 0x80020a <adcPart+0x1>
     f1c:	80 db       	rcall	.-2304   	; 0x61e <classify>
     f1e:	c7 58       	subi	r28, 0x87	; 135
     f20:	dd 4f       	sbci	r29, 0xFD	; 253
     f22:	88 83       	st	Y, r24
				Parts[countPart+1] = Parts[countPart];//Initialize next array index
     f24:	e0 91 65 02 	lds	r30, 0x0265	; 0x800265 <countPart>
     f28:	f0 e0       	ldi	r31, 0x00	; 0
     f2a:	a0 91 65 02 	lds	r26, 0x0265	; 0x800265 <countPart>
     f2e:	b0 e0       	ldi	r27, 0x00	; 0
     f30:	a7 58       	subi	r26, 0x87	; 135
     f32:	bd 4f       	sbci	r27, 0xFD	; 253
     f34:	8c 91       	ld	r24, X
     f36:	e6 58       	subi	r30, 0x86	; 134
     f38:	fd 4f       	sbci	r31, 0xFD	; 253
     f3a:	80 83       	st	Z, r24
				countPart +=1;//increment part counter
     f3c:	80 91 65 02 	lds	r24, 0x0265	; 0x800265 <countPart>
     f40:	8f 5f       	subi	r24, 0xFF	; 255
     f42:	80 93 65 02 	sts	0x0265, r24	; 0x800265 <countPart>
				if(countPart==PARTS_SIZE)
     f46:	80 91 65 02 	lds	r24, 0x0265	; 0x800265 <countPart>
     f4a:	84 36       	cpi	r24, 0x64	; 100
     f4c:	81 f4       	brne	.+32     	; 0xf6e <__vector_2+0x162>
				{//roll over if at parts size
					Parts[0] = Parts[countPart-1];
     f4e:	e0 91 65 02 	lds	r30, 0x0265	; 0x800265 <countPart>
     f52:	f0 e0       	ldi	r31, 0x00	; 0
     f54:	a9 e7       	ldi	r26, 0x79	; 121
     f56:	b2 e0       	ldi	r27, 0x02	; 2
     f58:	e8 58       	subi	r30, 0x88	; 136
     f5a:	fd 4f       	sbci	r31, 0xFD	; 253
     f5c:	80 81       	ld	r24, Z
     f5e:	8c 93       	st	X, r24
					Parts[1] = Parts[0];
     f60:	11 96       	adiw	r26, 0x01	; 1
     f62:	8c 93       	st	X, r24
					countPart = 1;
     f64:	81 e0       	ldi	r24, 0x01	; 1
     f66:	80 93 65 02 	sts	0x0265, r24	; 0x800265 <countPart>
					ROLLFLAG = 1;
     f6a:	80 93 6c 02 	sts	0x026C, r24	; 0x80026c <ROLLFLAG>
				}
			}
			EIFR |= _BV(INT1);//reset interrupt flag (for edge case) 
     f6e:	8c b3       	in	r24, 0x1c	; 28
     f70:	82 60       	ori	r24, 0x02	; 2
     f72:	8c bb       	out	0x1c, r24	; 28
		}//LO	
	}//else
}//OR
     f74:	ff 91       	pop	r31
     f76:	ef 91       	pop	r30
     f78:	df 91       	pop	r29
     f7a:	cf 91       	pop	r28
     f7c:	bf 91       	pop	r27
     f7e:	af 91       	pop	r26
     f80:	9f 91       	pop	r25
     f82:	8f 91       	pop	r24
     f84:	7f 91       	pop	r23
     f86:	6f 91       	pop	r22
     f88:	5f 91       	pop	r21
     f8a:	4f 91       	pop	r20
     f8c:	3f 91       	pop	r19
     f8e:	2f 91       	pop	r18
     f90:	0f 90       	pop	r0
     f92:	0b be       	out	0x3b, r0	; 59
     f94:	0f 90       	pop	r0
     f96:	0f be       	out	0x3f, r0	; 63
     f98:	0f 90       	pop	r0
     f9a:	1f 90       	pop	r1
     f9c:	18 95       	reti

00000f9e <__vector_3>:
rocking or sliding of the parts.

RUNTIME ~800cc
                                                                  */
/************************************************************************/
ISR(INT2_vect){
     f9e:	1f 92       	push	r1
     fa0:	0f 92       	push	r0
     fa2:	0f b6       	in	r0, 0x3f	; 63
     fa4:	0f 92       	push	r0
     fa6:	11 24       	eor	r1, r1
     fa8:	0b b6       	in	r0, 0x3b	; 59
     faa:	0f 92       	push	r0
     fac:	2f 93       	push	r18
     fae:	3f 93       	push	r19
     fb0:	4f 93       	push	r20
     fb2:	5f 93       	push	r21
     fb4:	6f 93       	push	r22
     fb6:	7f 93       	push	r23
     fb8:	8f 93       	push	r24
     fba:	9f 93       	push	r25
     fbc:	af 93       	push	r26
     fbe:	bf 93       	push	r27
     fc0:	ef 93       	push	r30
     fc2:	ff 93       	push	r31
	
	if(!EXFLAG)
     fc4:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <EXFLAG>
     fc8:	81 11       	cpse	r24, r1
     fca:	36 c0       	rjmp	.+108    	; 0x1038 <__EEPROM_REGION_LENGTH__+0x38>
	{//Part is entering EX
		
		if(debounce(2, 0, NOISECHECK))
     fcc:	48 e0       	ldi	r20, 0x08	; 8
     fce:	50 e0       	ldi	r21, 0x00	; 0
     fd0:	60 e0       	ldi	r22, 0x00	; 0
     fd2:	82 e0       	ldi	r24, 0x02	; 2
     fd4:	37 db       	rcall	.-2450   	; 0x644 <debounce>
     fd6:	88 23       	and	r24, r24
     fd8:	09 f4       	brne	.+2      	; 0xfdc <__vector_3+0x3e>
     fda:	a3 c0       	rjmp	.+326    	; 0x1122 <__EEPROM_REGION_LENGTH__+0x122>
		{//FILTER noise
				EXFLAG =1;
     fdc:	91 e0       	ldi	r25, 0x01	; 1
     fde:	90 93 6f 02 	sts	0x026F, r25	; 0x80026f <EXFLAG>
				// Turn on rising edge
				EIMSK &= ~_BV(INT2);
     fe2:	8d b3       	in	r24, 0x1d	; 29
     fe4:	8b 7f       	andi	r24, 0xFB	; 251
     fe6:	8d bb       	out	0x1d, r24	; 29
				EICRA |= _BV(ISC20);
     fe8:	e9 e6       	ldi	r30, 0x69	; 105
     fea:	f0 e0       	ldi	r31, 0x00	; 0
     fec:	80 81       	ld	r24, Z
     fee:	80 61       	ori	r24, 0x10	; 16
     ff0:	80 83       	st	Z, r24
				EIMSK |= _BV(INT2); //Enable Interrupt
     ff2:	8d b3       	in	r24, 0x1d	; 29
     ff4:	84 60       	ori	r24, 0x04	; 4
     ff6:	8d bb       	out	0x1d, r24	; 29
				EIFR |= _BV(INT2);
     ff8:	8c b3       	in	r24, 0x1c	; 28
     ffa:	84 60       	ori	r24, 0x04	; 4
     ffc:	8c bb       	out	0x1c, r24	; 28
				
				SORTFLAG = 1;//Part need sorting
     ffe:	90 93 66 02 	sts	0x0266, r25	; 0x800266 <SORTFLAG>
				if(HOLDFLAG)
    1002:	80 91 6b 02 	lds	r24, 0x026B	; 0x80026b <HOLDFLAG>
    1006:	88 23       	and	r24, r24
				{//if the previous part has not finished sorting
					brakeMotor();//stop the belt
    1008:	41 f0       	breq	.+16     	; 0x101a <__EEPROM_REGION_LENGTH__+0x1a>
    100a:	33 da       	rcall	.-2970   	; 0x472 <brakeMotor>
					enterdropTime = BRAKE_DROP_TIME;//set the drop time
    100c:	88 ed       	ldi	r24, 0xD8	; 216
    100e:	99 e5       	ldi	r25, 0x59	; 89
    1010:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
    1014:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
    1018:	06 c0       	rjmp	.+12     	; 0x1026 <__EEPROM_REGION_LENGTH__+0x26>
				}else
				{//else keep the belt moving
					enterdropTime = ENTER_DROP_TIME;//set the drop time
    101a:	84 ee       	ldi	r24, 0xE4	; 228
    101c:	97 e5       	ldi	r25, 0x57	; 87
    101e:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
    1022:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
				}
				EXTime_s = runTime_d;//record time part entered
    1026:	80 91 60 02 	lds	r24, 0x0260	; 0x800260 <runTime_d>
    102a:	90 91 61 02 	lds	r25, 0x0261	; 0x800261 <runTime_d+0x1>
    102e:	90 93 59 02 	sts	0x0259, r25	; 0x800259 <EXTime_s+0x1>
    1032:	80 93 58 02 	sts	0x0258, r24	; 0x800258 <EXTime_s>
    1036:	75 c0       	rjmp	.+234    	; 0x1122 <__EEPROM_REGION_LENGTH__+0x122>
		}//LO
	}else
	{//Part is leaving EX
		
		if(debounce(2,1, NOISECHECK) && ((runTime_d - EXTime_s)>SORTTIME))
    1038:	48 e0       	ldi	r20, 0x08	; 8
    103a:	50 e0       	ldi	r21, 0x00	; 0
    103c:	61 e0       	ldi	r22, 0x01	; 1
    103e:	82 e0       	ldi	r24, 0x02	; 2
    1040:	01 db       	rcall	.-2558   	; 0x644 <debounce>
    1042:	88 23       	and	r24, r24
    1044:	09 f4       	brne	.+2      	; 0x1048 <__EEPROM_REGION_LENGTH__+0x48>
    1046:	6d c0       	rjmp	.+218    	; 0x1122 <__EEPROM_REGION_LENGTH__+0x122>
    1048:	80 91 60 02 	lds	r24, 0x0260	; 0x800260 <runTime_d>
    104c:	90 91 61 02 	lds	r25, 0x0261	; 0x800261 <runTime_d+0x1>
    1050:	20 91 58 02 	lds	r18, 0x0258	; 0x800258 <EXTime_s>
    1054:	30 91 59 02 	lds	r19, 0x0259	; 0x800259 <EXTime_s+0x1>
    1058:	82 1b       	sub	r24, r18
    105a:	93 0b       	sbc	r25, r19
    105c:	06 97       	sbiw	r24, 0x06	; 6
    105e:	08 f4       	brcc	.+2      	; 0x1062 <__EEPROM_REGION_LENGTH__+0x62>
    1060:	60 c0       	rjmp	.+192    	; 0x1122 <__EEPROM_REGION_LENGTH__+0x122>
		{//FILTER noise and double edge detection
				EXFLAG = 0;
    1062:	10 92 6f 02 	sts	0x026F, r1	; 0x80026f <EXFLAG>
				//Turn on falling edge
				EIMSK &= ~_BV(INT2);
    1066:	8d b3       	in	r24, 0x1d	; 29
    1068:	8b 7f       	andi	r24, 0xFB	; 251
    106a:	8d bb       	out	0x1d, r24	; 29
				EICRA &= ~(_BV(ISC20));
    106c:	e9 e6       	ldi	r30, 0x69	; 105
    106e:	f0 e0       	ldi	r31, 0x00	; 0
    1070:	80 81       	ld	r24, Z
    1072:	8f 7e       	andi	r24, 0xEF	; 239
    1074:	80 83       	st	Z, r24
				EIMSK |= _BV(INT2);
    1076:	8d b3       	in	r24, 0x1d	; 29
    1078:	84 60       	ori	r24, 0x04	; 4
    107a:	8d bb       	out	0x1d, r24	; 29
				EIFR |= _BV(INT2);
    107c:	8c b3       	in	r24, 0x1c	; 28
    107e:	84 60       	ori	r24, 0x04	; 4
    1080:	8c bb       	out	0x1c, r24	; 28
                
				updateCount(Parts[countSort]);//Update the sorted count for display
    1082:	e0 91 64 02 	lds	r30, 0x0264	; 0x800264 <countSort>
    1086:	f0 e0       	ldi	r31, 0x00	; 0
    1088:	e7 58       	subi	r30, 0x87	; 135
    108a:	fd 4f       	sbci	r31, 0xFD	; 253
    108c:	80 81       	ld	r24, Z
    108e:	3d db       	rcall	.-2438   	; 0x70a <updateCount>
				
				
				
				if(countSort<countPart || ROLLFLAG)
    1090:	90 91 64 02 	lds	r25, 0x0264	; 0x800264 <countSort>
    1094:	80 91 65 02 	lds	r24, 0x0265	; 0x800265 <countPart>
    1098:	98 17       	cp	r25, r24
    109a:	20 f0       	brcs	.+8      	; 0x10a4 <__EEPROM_REGION_LENGTH__+0xa4>
    109c:	80 91 6c 02 	lds	r24, 0x026C	; 0x80026c <ROLLFLAG>
    10a0:	88 23       	and	r24, r24
    10a2:	81 f0       	breq	.+32     	; 0x10c4 <__EEPROM_REGION_LENGTH__+0xc4>
				{//if still parts to sort
					countSort+=1;//go to next part
    10a4:	80 91 64 02 	lds	r24, 0x0264	; 0x800264 <countSort>
    10a8:	8f 5f       	subi	r24, 0xFF	; 255
    10aa:	80 93 64 02 	sts	0x0264, r24	; 0x800264 <countSort>
					if(countSort==PARTS_SIZE)
    10ae:	80 91 64 02 	lds	r24, 0x0264	; 0x800264 <countSort>
    10b2:	84 36       	cpi	r24, 0x64	; 100
    10b4:	29 f4       	brne	.+10     	; 0x10c0 <__EEPROM_REGION_LENGTH__+0xc0>
					{//roll over if at parts size
						countSort = 1;
    10b6:	81 e0       	ldi	r24, 0x01	; 1
    10b8:	80 93 64 02 	sts	0x0264, r24	; 0x800264 <countSort>
						ROLLFLAG = 0;
    10bc:	10 92 6c 02 	sts	0x026C, r1	; 0x80026c <ROLLFLAG>
					}
					TARGETFLAG =0;//New target; reset flag
    10c0:	10 92 6a 02 	sts	0x026A, r1	; 0x80026a <TARGETFLAG>
				}
				
				if(abs(CurError)>DROP_REGION)
    10c4:	80 91 74 02 	lds	r24, 0x0274	; 0x800274 <CurError>
    10c8:	90 91 75 02 	lds	r25, 0x0275	; 0x800275 <CurError+0x1>
    10cc:	99 23       	and	r25, r25
    10ce:	1c f4       	brge	.+6      	; 0x10d6 <__EEPROM_REGION_LENGTH__+0xd6>
    10d0:	91 95       	neg	r25
    10d2:	81 95       	neg	r24
    10d4:	91 09       	sbc	r25, r1
    10d6:	0f 97       	sbiw	r24, 0x0f	; 15
    10d8:	24 f0       	brlt	.+8      	; 0x10e2 <__EEPROM_REGION_LENGTH__+0xe2>
				{//if stepper hasn't reached the drop zone for previous part
					HOLDFLAG = 1;//set hold flag to keep moving to previous target position
    10da:	81 e0       	ldi	r24, 0x01	; 1
    10dc:	80 93 6b 02 	sts	0x026B, r24	; 0x80026b <HOLDFLAG>
				}else
				{//else start the belt to drop the part
					runMotor();
    10e0:	01 c0       	rjmp	.+2      	; 0x10e4 <__EEPROM_REGION_LENGTH__+0xe4>
    10e2:	28 da       	rcall	.-2992   	; 0x534 <runMotor>
				}
				//reset flag
                PAUSEFLAG=0;
    10e4:	10 92 69 02 	sts	0x0269, r1	; 0x800269 <PAUSEFLAG>
				SORTFLAG = 0;
    10e8:	10 92 66 02 	sts	0x0266, r1	; 0x800266 <SORTFLAG>
				
				DROPFLAG = 1;//part is now dropping into the bin
    10ec:	81 e0       	ldi	r24, 0x01	; 1
    10ee:	80 93 67 02 	sts	0x0267, r24	; 0x800267 <DROPFLAG>
				
				//record time for part to hit bucket. 
				//Correct for next time ISR(TIMER3_COMPA_vect) runs
				dropTime = DROP_TIME - (OCR3A - TCNT3);   
    10f2:	80 91 94 00 	lds	r24, 0x0094	; 0x800094 <__TEXT_REGION_LENGTH__+0x7c0094>
    10f6:	90 91 95 00 	lds	r25, 0x0095	; 0x800095 <__TEXT_REGION_LENGTH__+0x7c0095>
    10fa:	20 91 98 00 	lds	r18, 0x0098	; 0x800098 <__TEXT_REGION_LENGTH__+0x7c0098>
    10fe:	30 91 99 00 	lds	r19, 0x0099	; 0x800099 <__TEXT_REGION_LENGTH__+0x7c0099>
    1102:	82 1b       	sub	r24, r18
    1104:	93 0b       	sbc	r25, r19
    1106:	80 5b       	subi	r24, 0xB0	; 176
    1108:	99 4b       	sbci	r25, 0xB9	; 185
    110a:	90 93 03 02 	sts	0x0203, r25	; 0x800203 <dropTime+0x1>
    110e:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <dropTime>
				     
			EXTime_s = runTime_d;//record time part exited	
    1112:	80 91 60 02 	lds	r24, 0x0260	; 0x800260 <runTime_d>
    1116:	90 91 61 02 	lds	r25, 0x0261	; 0x800261 <runTime_d+0x1>
    111a:	90 93 59 02 	sts	0x0259, r25	; 0x800259 <EXTime_s+0x1>
    111e:	80 93 58 02 	sts	0x0258, r24	; 0x800258 <EXTime_s>
		}//HI
	}	
}//EX
    1122:	ff 91       	pop	r31
    1124:	ef 91       	pop	r30
    1126:	bf 91       	pop	r27
    1128:	af 91       	pop	r26
    112a:	9f 91       	pop	r25
    112c:	8f 91       	pop	r24
    112e:	7f 91       	pop	r23
    1130:	6f 91       	pop	r22
    1132:	5f 91       	pop	r21
    1134:	4f 91       	pop	r20
    1136:	3f 91       	pop	r19
    1138:	2f 91       	pop	r18
    113a:	0f 90       	pop	r0
    113c:	0b be       	out	0x3b, r0	; 59
    113e:	0f 90       	pop	r0
    1140:	0f be       	out	0x3f, r0	; 63
    1142:	0f 90       	pop	r0
    1144:	1f 90       	pop	r1
    1146:	18 95       	reti

00001148 <__vector_32>:

The ISR also triggers the ISR for motor control, ISR(PCINT0_vect).

RUNTIME ~400cc                                                          */
/************************************************************************/
ISR(TIMER3_COMPA_vect){
    1148:	1f 92       	push	r1
    114a:	0f 92       	push	r0
    114c:	0f b6       	in	r0, 0x3f	; 63
    114e:	0f 92       	push	r0
    1150:	11 24       	eor	r1, r1
    1152:	0b b6       	in	r0, 0x3b	; 59
    1154:	0f 92       	push	r0
    1156:	2f 93       	push	r18
    1158:	3f 93       	push	r19
    115a:	4f 93       	push	r20
    115c:	5f 93       	push	r21
    115e:	6f 93       	push	r22
    1160:	7f 93       	push	r23
    1162:	8f 93       	push	r24
    1164:	9f 93       	push	r25
    1166:	af 93       	push	r26
    1168:	bf 93       	push	r27
    116a:	ef 93       	push	r30
    116c:	ff 93       	push	r31
//CONTROL STEPPER
	step();//step stepper and update the position
    116e:	8b d1       	rcall	.+790    	; 0x1486 <step>
	stepUpdateError(); //calculate the new stepper position error (CurError)
    1170:	d0 d1       	rcall	.+928    	; 0x1512 <stepUpdateError>
	stepUpdateDir(); //update the stepper direction
    1172:	51 d2       	rcall	.+1186   	; 0x1616 <stepUpdateDir>
    1174:	c7 d2       	rcall	.+1422   	; 0x1704 <stepUpdateDelay>
	stepUpdateDelay(); //update the stepper speed
    1176:	81 e0       	ldi	r24, 0x01	; 1
    1178:	80 93 68 02 	sts	0x0268, r24	; 0x800268 <CALCFLAG>
//CONTROL STEPPER

	//trigger motor controller.
	CALCFLAG = 1;
    117c:	95 b1       	in	r25, 0x05	; 5
    117e:	80 e1       	ldi	r24, 0x10	; 16
	PORTB ^= _BV(PINB4);
    1180:	89 27       	eor	r24, r25
    1182:	85 b9       	out	0x05, r24	; 5
    1184:	ff 91       	pop	r31
    1186:	ef 91       	pop	r30
}//stepTimer
    1188:	bf 91       	pop	r27
    118a:	af 91       	pop	r26
    118c:	9f 91       	pop	r25
    118e:	8f 91       	pop	r24
    1190:	7f 91       	pop	r23
    1192:	6f 91       	pop	r22
    1194:	5f 91       	pop	r21
    1196:	4f 91       	pop	r20
    1198:	3f 91       	pop	r19
    119a:	2f 91       	pop	r18
    119c:	0f 90       	pop	r0
    119e:	0b be       	out	0x3b, r0	; 59
    11a0:	0f 90       	pop	r0
    11a2:	0f be       	out	0x3f, r0	; 63
    11a4:	0f 90       	pop	r0
    11a6:	1f 90       	pop	r1
    11a8:	18 95       	reti

000011aa <__vector_29>:
    11aa:	1f 92       	push	r1
    11ac:	0f 92       	push	r0
an ADC conversion completes. When it runs it compares the current ADC value
to the lowest of the sequence and replaces it if it is lower. If the part being
scanned is still within OR it triggers another conversion. Otherwise, it exits
without restarting the ADC.                                                 */
/************************************************************************/
ISR(ADC_vect){
    11ae:	0f b6       	in	r0, 0x3f	; 63
    11b0:	0f 92       	push	r0
    11b2:	11 24       	eor	r1, r1
    11b4:	0b b6       	in	r0, 0x3b	; 59
    11b6:	0f 92       	push	r0
    11b8:	2f 93       	push	r18
    11ba:	3f 93       	push	r19
    11bc:	8f 93       	push	r24
    11be:	9f 93       	push	r25
    11c0:	ef 93       	push	r30
    11c2:	ff 93       	push	r31

	//if ADC is lower than value
	adcTemp = ADCL;
    11c4:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7c0078>
    11c8:	90 e0       	ldi	r25, 0x00	; 0
    11ca:	90 93 08 02 	sts	0x0208, r25	; 0x800208 <adcTemp+0x1>
    11ce:	80 93 07 02 	sts	0x0207, r24	; 0x800207 <adcTemp>
	adcTemp+= (ADCH<<8);
    11d2:	80 91 79 00 	lds	r24, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7c0079>
    11d6:	90 e0       	ldi	r25, 0x00	; 0
    11d8:	98 2f       	mov	r25, r24
    11da:	88 27       	eor	r24, r24
    11dc:	20 91 07 02 	lds	r18, 0x0207	; 0x800207 <adcTemp>
    11e0:	30 91 08 02 	lds	r19, 0x0208	; 0x800208 <adcTemp+0x1>
    11e4:	82 0f       	add	r24, r18
    11e6:	93 1f       	adc	r25, r19
    11e8:	90 93 08 02 	sts	0x0208, r25	; 0x800208 <adcTemp+0x1>
    11ec:	80 93 07 02 	sts	0x0207, r24	; 0x800207 <adcTemp>
	countADC+=1;
    11f0:	80 91 62 02 	lds	r24, 0x0262	; 0x800262 <countADC>
    11f4:	90 91 63 02 	lds	r25, 0x0263	; 0x800263 <countADC+0x1>
    11f8:	01 96       	adiw	r24, 0x01	; 1
    11fa:	90 93 63 02 	sts	0x0263, r25	; 0x800263 <countADC+0x1>
    11fe:	80 93 62 02 	sts	0x0262, r24	; 0x800262 <countADC>
	
	if(adcTemp<adcPart){
    1202:	20 91 07 02 	lds	r18, 0x0207	; 0x800207 <adcTemp>
    1206:	30 91 08 02 	lds	r19, 0x0208	; 0x800208 <adcTemp+0x1>
    120a:	80 91 09 02 	lds	r24, 0x0209	; 0x800209 <adcPart>
    120e:	90 91 0a 02 	lds	r25, 0x020A	; 0x80020a <adcPart+0x1>
    1212:	28 17       	cp	r18, r24
    1214:	39 07       	cpc	r19, r25
    1216:	40 f4       	brcc	.+16     	; 0x1228 <__vector_29+0x7e>
		adcPart = adcTemp;// set value to ADC
    1218:	80 91 07 02 	lds	r24, 0x0207	; 0x800207 <adcTemp>
    121c:	90 91 08 02 	lds	r25, 0x0208	; 0x800208 <adcTemp+0x1>
    1220:	90 93 0a 02 	sts	0x020A, r25	; 0x80020a <adcPart+0x1>
    1224:	80 93 09 02 	sts	0x0209, r24	; 0x800209 <adcPart>
	}
	
	if(!ORFLAG){
    1228:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <ORFLAG>
    122c:	81 11       	cpse	r24, r1
    122e:	05 c0       	rjmp	.+10     	; 0x123a <__vector_29+0x90>
		ADCSRA |=_BV( ADSC);
    1230:	ea e7       	ldi	r30, 0x7A	; 122
    1232:	f0 e0       	ldi	r31, 0x00	; 0
    1234:	80 81       	ld	r24, Z
    1236:	80 64       	ori	r24, 0x40	; 64
    1238:	80 83       	st	Z, r24
	}
}//ADC
    123a:	ff 91       	pop	r31
    123c:	ef 91       	pop	r30
    123e:	9f 91       	pop	r25
    1240:	8f 91       	pop	r24
    1242:	3f 91       	pop	r19
    1244:	2f 91       	pop	r18
    1246:	0f 90       	pop	r0
    1248:	0b be       	out	0x3b, r0	; 59
    124a:	0f 90       	pop	r0
    124c:	0f be       	out	0x3f, r0	; 63
    124e:	0f 90       	pop	r0
    1250:	1f 90       	pop	r1
    1252:	18 95       	reti

00001254 <__vector_4>:
/************************************************************************/
/* DESCRIPTION: This ISR is connected to the HE sensor. When triggered
it calibrates the stepper position to the known position of the HE sensors.
Its also sets the HALLSENSOR flag                                            */
/************************************************************************/
ISR(INT3_vect){
    1254:	1f 92       	push	r1
    1256:	0f 92       	push	r0
    1258:	0f b6       	in	r0, 0x3f	; 63
    125a:	0f 92       	push	r0
    125c:	11 24       	eor	r1, r1
    125e:	0b b6       	in	r0, 0x3b	; 59
    1260:	0f 92       	push	r0
    1262:	2f 93       	push	r18
    1264:	3f 93       	push	r19
    1266:	4f 93       	push	r20
    1268:	5f 93       	push	r21
    126a:	6f 93       	push	r22
    126c:	7f 93       	push	r23
    126e:	8f 93       	push	r24
    1270:	9f 93       	push	r25
    1272:	af 93       	push	r26
    1274:	bf 93       	push	r27
    1276:	ef 93       	push	r30
    1278:	ff 93       	push	r31
	if(debounce(3, 1, NOISECHECK)){
    127a:	48 e0       	ldi	r20, 0x08	; 8
    127c:	50 e0       	ldi	r21, 0x00	; 0
    127e:	61 e0       	ldi	r22, 0x01	; 1
    1280:	83 e0       	ldi	r24, 0x03	; 3
    1282:	e0 d9       	rcall	.-3136   	; 0x644 <debounce>
    1284:	88 23       	and	r24, r24
    1286:	31 f0       	breq	.+12     	; 0x1294 <__vector_4+0x40>
		//stepStop();
		CurPosition = B_ID;
    1288:	82 e3       	ldi	r24, 0x32	; 50
    128a:	80 93 11 02 	sts	0x0211, r24	; 0x800211 <CurPosition>
		HALLSENSOR= 1;
    128e:	81 e0       	ldi	r24, 0x01	; 1
    1290:	80 93 71 02 	sts	0x0271, r24	; 0x800271 <HALLSENSOR>
	}
}//HE
    1294:	ff 91       	pop	r31
    1296:	ef 91       	pop	r30
    1298:	bf 91       	pop	r27
    129a:	af 91       	pop	r26
    129c:	9f 91       	pop	r25
    129e:	8f 91       	pop	r24
    12a0:	7f 91       	pop	r23
    12a2:	6f 91       	pop	r22
    12a4:	5f 91       	pop	r21
    12a6:	4f 91       	pop	r20
    12a8:	3f 91       	pop	r19
    12aa:	2f 91       	pop	r18
    12ac:	0f 90       	pop	r0
    12ae:	0b be       	out	0x3b, r0	; 59
    12b0:	0f 90       	pop	r0
    12b2:	0f be       	out	0x3f, r0	; 63
    12b4:	0f 90       	pop	r0
    12b6:	1f 90       	pop	r1
    12b8:	18 95       	reti

000012ba <__vector_1>:

/************************************************************************/
/* DESCRIPTION: This ISR is connected to the PAUSE button. When pressed 
it is debounced and then toggle enable                                         */
/************************************************************************/
ISR(INT0_vect){
    12ba:	1f 92       	push	r1
    12bc:	0f 92       	push	r0
    12be:	0f b6       	in	r0, 0x3f	; 63
    12c0:	0f 92       	push	r0
    12c2:	11 24       	eor	r1, r1
    12c4:	0b b6       	in	r0, 0x3b	; 59
    12c6:	0f 92       	push	r0
    12c8:	2f 93       	push	r18
    12ca:	3f 93       	push	r19
    12cc:	4f 93       	push	r20
    12ce:	5f 93       	push	r21
    12d0:	6f 93       	push	r22
    12d2:	7f 93       	push	r23
    12d4:	8f 93       	push	r24
    12d6:	9f 93       	push	r25
    12d8:	af 93       	push	r26
    12da:	bf 93       	push	r27
    12dc:	ef 93       	push	r30
    12de:	ff 93       	push	r31
	if(debounce(0, 0, BOUNCECHECK)){
    12e0:	44 ef       	ldi	r20, 0xF4	; 244
    12e2:	51 e0       	ldi	r21, 0x01	; 1
    12e4:	60 e0       	ldi	r22, 0x00	; 0
    12e6:	80 e0       	ldi	r24, 0x00	; 0
    12e8:	ad d9       	rcall	.-3238   	; 0x644 <debounce>
    12ea:	88 23       	and	r24, r24
    12ec:	51 f0       	breq	.+20     	; 0x1302 <__vector_1+0x48>
		if(ENABLE)
    12ee:	80 91 0c 02 	lds	r24, 0x020C	; 0x80020c <ENABLE>
    12f2:	88 23       	and	r24, r24
    12f4:	19 f0       	breq	.+6      	; 0x12fc <__vector_1+0x42>
		{
			ENABLE = 0;
    12f6:	10 92 0c 02 	sts	0x020C, r1	; 0x80020c <ENABLE>
    12fa:	03 c0       	rjmp	.+6      	; 0x1302 <__vector_1+0x48>
		}else
		{
			ENABLE = 1;
    12fc:	81 e0       	ldi	r24, 0x01	; 1
    12fe:	80 93 0c 02 	sts	0x020C, r24	; 0x80020c <ENABLE>
		}
	}
}//ISR Pause Button
    1302:	ff 91       	pop	r31
    1304:	ef 91       	pop	r30
    1306:	bf 91       	pop	r27
    1308:	af 91       	pop	r26
    130a:	9f 91       	pop	r25
    130c:	8f 91       	pop	r24
    130e:	7f 91       	pop	r23
    1310:	6f 91       	pop	r22
    1312:	5f 91       	pop	r21
    1314:	4f 91       	pop	r20
    1316:	3f 91       	pop	r19
    1318:	2f 91       	pop	r18
    131a:	0f 90       	pop	r0
    131c:	0b be       	out	0x3b, r0	; 59
    131e:	0f 90       	pop	r0
    1320:	0f be       	out	0x3f, r0	; 63
    1322:	0f 90       	pop	r0
    1324:	1f 90       	pop	r1
    1326:	18 95       	reti

00001328 <__vector_10>:
/************************************************************************/
/* DESCRIPTION: This ISR is connected to the RAMPDOWN button. It begins
then ramp down sequence by setting the RAMPDOWN flag.                                          */
/************************************************************************/
ISR(PCINT1_vect)
{
    1328:	1f 92       	push	r1
    132a:	0f 92       	push	r0
    132c:	0f b6       	in	r0, 0x3f	; 63
    132e:	0f 92       	push	r0
    1330:	11 24       	eor	r1, r1
    1332:	0b b6       	in	r0, 0x3b	; 59
    1334:	0f 92       	push	r0
    1336:	2f 93       	push	r18
    1338:	3f 93       	push	r19
    133a:	4f 93       	push	r20
    133c:	5f 93       	push	r21
    133e:	6f 93       	push	r22
    1340:	7f 93       	push	r23
    1342:	8f 93       	push	r24
    1344:	9f 93       	push	r25
    1346:	af 93       	push	r26
    1348:	bf 93       	push	r27
    134a:	ef 93       	push	r30
    134c:	ff 93       	push	r31
	if(debouncePINJ(0, 1, BOUNCECHECK)){
    134e:	44 ef       	ldi	r20, 0xF4	; 244
    1350:	51 e0       	ldi	r21, 0x01	; 1
    1352:	61 e0       	ldi	r22, 0x01	; 1
    1354:	80 e0       	ldi	r24, 0x00	; 0
    1356:	a7 d9       	rcall	.-3250   	; 0x6a6 <debouncePINJ>
    1358:	88 23       	and	r24, r24
    135a:	59 f0       	breq	.+22     	; 0x1372 <__vector_10+0x4a>
		RAMPDOWN = 1;
    135c:	81 e0       	ldi	r24, 0x01	; 1
    135e:	80 93 70 02 	sts	0x0270, r24	; 0x800270 <RAMPDOWN>
		rampTime_d = runTime_d;	
    1362:	80 91 60 02 	lds	r24, 0x0260	; 0x800260 <runTime_d>
    1366:	90 91 61 02 	lds	r25, 0x0261	; 0x800261 <runTime_d+0x1>
    136a:	90 93 5d 02 	sts	0x025D, r25	; 0x80025d <rampTime_d+0x1>
    136e:	80 93 5c 02 	sts	0x025C, r24	; 0x80025c <rampTime_d>
	}
}//ISR Ramp Button
    1372:	ff 91       	pop	r31
    1374:	ef 91       	pop	r30
    1376:	bf 91       	pop	r27
    1378:	af 91       	pop	r26
    137a:	9f 91       	pop	r25
    137c:	8f 91       	pop	r24
    137e:	7f 91       	pop	r23
    1380:	6f 91       	pop	r22
    1382:	5f 91       	pop	r21
    1384:	4f 91       	pop	r20
    1386:	3f 91       	pop	r19
    1388:	2f 91       	pop	r18
    138a:	0f 90       	pop	r0
    138c:	0b be       	out	0x3b, r0	; 59
    138e:	0f 90       	pop	r0
    1390:	0f be       	out	0x3f, r0	; 63
    1392:	0f 90       	pop	r0
    1394:	1f 90       	pop	r1
    1396:	18 95       	reti

00001398 <__vector_9>:
NOTE: The reason this function is separate from ISR(TIMER3_COMPA_vect) is 
to allow the ADC ISR to run in between these functions. This achieves higher
precision classification for each part by allowing more ADC reads.                                     */
/************************************************************************/
ISR(PCINT0_vect)
{
    1398:	1f 92       	push	r1
    139a:	0f 92       	push	r0
    139c:	0f b6       	in	r0, 0x3f	; 63
    139e:	0f 92       	push	r0
    13a0:	11 24       	eor	r1, r1
    13a2:	0b b6       	in	r0, 0x3b	; 59
    13a4:	0f 92       	push	r0
    13a6:	2f 93       	push	r18
    13a8:	3f 93       	push	r19
    13aa:	4f 93       	push	r20
    13ac:	5f 93       	push	r21
    13ae:	6f 93       	push	r22
    13b0:	7f 93       	push	r23
    13b2:	8f 93       	push	r24
    13b4:	9f 93       	push	r25
    13b6:	af 93       	push	r26
    13b8:	bf 93       	push	r27
    13ba:	ef 93       	push	r30
    13bc:	ff 93       	push	r31
	if(CALCFLAG)
    13be:	80 91 68 02 	lds	r24, 0x0268	; 0x800268 <CALCFLAG>
    13c2:	88 23       	and	r24, r24
    13c4:	09 f4       	brne	.+2      	; 0x13c8 <__vector_9+0x30>
    13c6:	4a c0       	rjmp	.+148    	; 0x145c <__vector_9+0xc4>
	{//if motor control is requested (NOISE filter)
		
		if(SORTFLAG ^ HOLDFLAG)
    13c8:	90 91 66 02 	lds	r25, 0x0266	; 0x800266 <SORTFLAG>
    13cc:	80 91 6b 02 	lds	r24, 0x026B	; 0x80026b <HOLDFLAG>
    13d0:	98 17       	cp	r25, r24
    13d2:	81 f0       	breq	.+32     	; 0x13f4 <__vector_9+0x5c>
		{//If a piece needs sorting XOR a the stepper is holding target for a part
			
			//Calculate the time till stepper enters the drop zone
			if(CalcEnterTime())
    13d4:	0e 94 52 01 	call	0x2a4	; 0x2a4 <CalcEnterTime>
    13d8:	88 23       	and	r24, r24
    13da:	41 f0       	breq	.+16     	; 0x13ec <__vector_9+0x54>
			{//if stepper will not reach the drop zone before part falls
				brakeMotor();//brake motor to slow or stop part
    13dc:	4a d8       	rcall	.-3948   	; 0x472 <brakeMotor>
				enterdropTime = BRAKE_DROP_TIME;//adjust new drop time
    13de:	88 ed       	ldi	r24, 0xD8	; 216
    13e0:	99 e5       	ldi	r25, 0x59	; 89
    13e2:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
    13e6:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
    13ea:	0c c0       	rjmp	.+24     	; 0x1404 <__vector_9+0x6c>
			}else
			{//else stepper will reach drop zone in time for the part to fall
				SORTFLAG = 0;//the part will be sorted correctly, reset flag
    13ec:	10 92 66 02 	sts	0x0266, r1	; 0x800266 <SORTFLAG>
				runMotor();//start the motor
    13f0:	a1 d8       	rcall	.-3774   	; 0x534 <runMotor>
    13f2:	08 c0       	rjmp	.+16     	; 0x1404 <__vector_9+0x6c>
			}
		}else if(SORTFLAG && HOLDFLAG)
    13f4:	80 91 66 02 	lds	r24, 0x0266	; 0x800266 <SORTFLAG>
    13f8:	88 23       	and	r24, r24
    13fa:	21 f0       	breq	.+8      	; 0x1404 <__vector_9+0x6c>
    13fc:	80 91 6b 02 	lds	r24, 0x026B	; 0x80026b <HOLDFLAG>
		{//if a new pieces needs to be sorted and a part is currently dropping
			brakeMotor();//stop the motor and wait for the part to finish dropping
    1400:	81 11       	cpse	r24, r1
    1402:	37 d8       	rcall	.-3986   	; 0x472 <brakeMotor>
		}
		
		
		
		if(DROPFLAG)
    1404:	80 91 67 02 	lds	r24, 0x0267	; 0x800267 <DROPFLAG>
    1408:	88 23       	and	r24, r24
    140a:	41 f1       	breq	.+80     	; 0x145c <__vector_9+0xc4>
		{//if a part has left EX and is dropping
			if(dropTime<CurDelay)
    140c:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <dropTime>
    1410:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <dropTime+0x1>
    1414:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <CurDelay>
    1418:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <CurDelay+0x1>
    141c:	28 17       	cp	r18, r24
    141e:	39 07       	cpc	r19, r25
    1420:	28 f4       	brcc	.+10     	; 0x142c <__vector_9+0x94>
			{//if the part will hit the bucket before the next step
				//reset flags; the part is sorted or missed
				DROPFLAG = 0;
    1422:	10 92 67 02 	sts	0x0267, r1	; 0x800267 <DROPFLAG>
				PAUSEFLAG = 0;
    1426:	10 92 69 02 	sts	0x0269, r1	; 0x800269 <PAUSEFLAG>
    142a:	18 c0       	rjmp	.+48     	; 0x145c <__vector_9+0xc4>
			}else
			{//else	
				dropTime -=CurDelay;//update the drop time
    142c:	20 91 76 02 	lds	r18, 0x0276	; 0x800276 <CurDelay>
    1430:	30 91 77 02 	lds	r19, 0x0277	; 0x800277 <CurDelay+0x1>
    1434:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <dropTime>
    1438:	90 91 03 02 	lds	r25, 0x0203	; 0x800203 <dropTime+0x1>
    143c:	82 1b       	sub	r24, r18
    143e:	93 0b       	sbc	r25, r19
    1440:	90 93 03 02 	sts	0x0203, r25	; 0x800203 <dropTime+0x1>
    1444:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <dropTime>
				//calculate the time until the stepper leaves the drop zone	
				if(CalcExitTime())
    1448:	0e 94 93 00 	call	0x126	; 0x126 <CalcExitTime>
    144c:	88 23       	and	r24, r24
    144e:	21 f0       	breq	.+8      	; 0x1458 <__vector_9+0xc0>
				{//if the stepper will exit before the parts drop
					PAUSEFLAG = 1;//slow down the stepper
    1450:	81 e0       	ldi	r24, 0x01	; 1
    1452:	80 93 69 02 	sts	0x0269, r24	; 0x800269 <PAUSEFLAG>
    1456:	02 c0       	rjmp	.+4      	; 0x145c <__vector_9+0xc4>
				}else
				{
					PAUSEFLAG = 0;//allow stepper to move as normal
    1458:	10 92 69 02 	sts	0x0269, r1	; 0x800269 <PAUSEFLAG>
				}
			}	
		}	
	}
	CALCFLAG = 0;//reset flag for next call
    145c:	10 92 68 02 	sts	0x0268, r1	; 0x800268 <CALCFLAG>
	
}
    1460:	ff 91       	pop	r31
    1462:	ef 91       	pop	r30
    1464:	bf 91       	pop	r27
    1466:	af 91       	pop	r26
    1468:	9f 91       	pop	r25
    146a:	8f 91       	pop	r24
    146c:	7f 91       	pop	r23
    146e:	6f 91       	pop	r22
    1470:	5f 91       	pop	r21
    1472:	4f 91       	pop	r20
    1474:	3f 91       	pop	r19
    1476:	2f 91       	pop	r18
    1478:	0f 90       	pop	r0
    147a:	0b be       	out	0x3b, r0	; 59
    147c:	0f 90       	pop	r0
    147e:	0f be       	out	0x3f, r0	; 63
    1480:	0f 90       	pop	r0
    1482:	1f 90       	pop	r1
    1484:	18 95       	reti

00001486 <step>:
the position and state variables, and resets the delay counter. It also 
handles roll over for CurState and CurPosition.
                                                               */
/************************************************************************/
uint8_t step(void){
	CurState = CurState + Dir;//Update CurState based on Dir
    1486:	90 91 73 02 	lds	r25, 0x0273	; 0x800273 <CurState>
    148a:	80 91 13 02 	lds	r24, 0x0213	; 0x800213 <Dir>
    148e:	89 0f       	add	r24, r25
    1490:	80 93 73 02 	sts	0x0273, r24	; 0x800273 <CurState>
	//stepper roll over
	if (4 <= CurState){CurState = 0;}
    1494:	80 91 73 02 	lds	r24, 0x0273	; 0x800273 <CurState>
    1498:	84 30       	cpi	r24, 0x04	; 4
    149a:	1c f0       	brlt	.+6      	; 0x14a2 <step+0x1c>
    149c:	10 92 73 02 	sts	0x0273, r1	; 0x800273 <CurState>
    14a0:	07 c0       	rjmp	.+14     	; 0x14b0 <step+0x2a>
	else if (-1 >= CurState){CurState = 3;}
    14a2:	80 91 73 02 	lds	r24, 0x0273	; 0x800273 <CurState>
    14a6:	88 23       	and	r24, r24
    14a8:	1c f4       	brge	.+6      	; 0x14b0 <step+0x2a>
    14aa:	83 e0       	ldi	r24, 0x03	; 3
    14ac:	80 93 73 02 	sts	0x0273, r24	; 0x800273 <CurState>
	
	PORTA = StepStates[CurState]; //Step
    14b0:	e0 91 73 02 	lds	r30, 0x0273	; 0x800273 <CurState>
    14b4:	0e 2e       	mov	r0, r30
    14b6:	00 0c       	add	r0, r0
    14b8:	ff 0b       	sbc	r31, r31
    14ba:	e3 5f       	subi	r30, 0xF3	; 243
    14bc:	fd 4f       	sbci	r31, 0xFD	; 253
    14be:	80 81       	ld	r24, Z
    14c0:	82 b9       	out	0x02, r24	; 2
	CurPosition = CurPosition + Dir;//Update CurPosition base on Dir
    14c2:	80 91 11 02 	lds	r24, 0x0211	; 0x800211 <CurPosition>
    14c6:	90 91 13 02 	lds	r25, 0x0213	; 0x800213 <Dir>
    14ca:	89 0f       	add	r24, r25
    14cc:	80 93 11 02 	sts	0x0211, r24	; 0x800211 <CurPosition>
	//protect against roll over
	if(CurPosition > 225 && Dir==1){CurPosition -=  200;}
    14d0:	80 91 11 02 	lds	r24, 0x0211	; 0x800211 <CurPosition>
    14d4:	82 3e       	cpi	r24, 0xE2	; 226
    14d6:	50 f0       	brcs	.+20     	; 0x14ec <step+0x66>
    14d8:	80 91 13 02 	lds	r24, 0x0213	; 0x800213 <Dir>
    14dc:	81 30       	cpi	r24, 0x01	; 1
    14de:	31 f4       	brne	.+12     	; 0x14ec <step+0x66>
    14e0:	80 91 11 02 	lds	r24, 0x0211	; 0x800211 <CurPosition>
    14e4:	88 5c       	subi	r24, 0xC8	; 200
    14e6:	80 93 11 02 	sts	0x0211, r24	; 0x800211 <CurPosition>
    14ea:	0d c0       	rjmp	.+26     	; 0x1506 <step+0x80>
	else if(CurPosition < 25 && Dir==-1){CurPosition += 200;}
    14ec:	80 91 11 02 	lds	r24, 0x0211	; 0x800211 <CurPosition>
    14f0:	89 31       	cpi	r24, 0x19	; 25
    14f2:	48 f4       	brcc	.+18     	; 0x1506 <step+0x80>
    14f4:	80 91 13 02 	lds	r24, 0x0213	; 0x800213 <Dir>
    14f8:	8f 3f       	cpi	r24, 0xFF	; 255
    14fa:	29 f4       	brne	.+10     	; 0x1506 <step+0x80>
    14fc:	80 91 11 02 	lds	r24, 0x0211	; 0x800211 <CurPosition>
    1500:	88 53       	subi	r24, 0x38	; 56
    1502:	80 93 11 02 	sts	0x0211, r24	; 0x800211 <CurPosition>
	
	TCNT3 = 0x0000;//Reset Counter
    1506:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x7c0095>
    150a:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x7c0094>
	
	return 1;	//return step;
}//step
    150e:	81 e0       	ldi	r24, 0x01	; 1
    1510:	08 95       	ret

00001512 <stepUpdateError>:
HOLDFLAG, PAUSEFLAG, and TARGETFLAG (see variable initialization for meaning).
                                                               */
/************************************************************************/
uint8_t stepUpdateError(void)
{
	if(HOLDFLAG)
    1512:	80 91 6b 02 	lds	r24, 0x026B	; 0x80026b <HOLDFLAG>
    1516:	88 23       	and	r24, r24
    1518:	89 f1       	breq	.+98     	; 0x157c <stepUpdateError+0x6a>
	{
		if(abs(CurError)<DROP_REGION)//We may need to check the time since slip to see if the part fell
    151a:	80 91 74 02 	lds	r24, 0x0274	; 0x800274 <CurError>
    151e:	90 91 75 02 	lds	r25, 0x0275	; 0x800275 <CurError+0x1>
    1522:	99 23       	and	r25, r25
    1524:	1c f4       	brge	.+6      	; 0x152c <stepUpdateError+0x1a>
    1526:	91 95       	neg	r25
    1528:	81 95       	neg	r24
    152a:	91 09       	sbc	r25, r1
    152c:	0e 97       	sbiw	r24, 0x0e	; 14
    152e:	b4 f4       	brge	.+44     	; 0x155c <stepUpdateError+0x4a>
		{//Maybe a reduced drop region and a delay to ensure piece hits
			HOLDFLAG = 0;
    1530:	10 92 6b 02 	sts	0x026B, r1	; 0x80026b <HOLDFLAG>
			PAUSEFLAG = 0;
    1534:	10 92 69 02 	sts	0x0269, r1	; 0x800269 <PAUSEFLAG>
			runMotor();
    1538:	0e 94 9a 02 	call	0x534	; 0x534 <runMotor>
			CurError = Parts[countSort] - CurPosition;
    153c:	e0 91 64 02 	lds	r30, 0x0264	; 0x800264 <countSort>
    1540:	f0 e0       	ldi	r31, 0x00	; 0
    1542:	e7 58       	subi	r30, 0x87	; 135
    1544:	fd 4f       	sbci	r31, 0xFD	; 253
    1546:	80 81       	ld	r24, Z
    1548:	20 91 11 02 	lds	r18, 0x0211	; 0x800211 <CurPosition>
    154c:	90 e0       	ldi	r25, 0x00	; 0
    154e:	82 1b       	sub	r24, r18
    1550:	91 09       	sbc	r25, r1
    1552:	90 93 75 02 	sts	0x0275, r25	; 0x800275 <CurError+0x1>
    1556:	80 93 74 02 	sts	0x0274, r24	; 0x800274 <CurError>
    155a:	1f c0       	rjmp	.+62     	; 0x159a <stepUpdateError+0x88>
		}else
		{
			CurError = Parts[countSort-1] - CurPosition;
    155c:	e0 91 64 02 	lds	r30, 0x0264	; 0x800264 <countSort>
    1560:	f0 e0       	ldi	r31, 0x00	; 0
    1562:	e8 58       	subi	r30, 0x88	; 136
    1564:	fd 4f       	sbci	r31, 0xFD	; 253
    1566:	80 81       	ld	r24, Z
    1568:	20 91 11 02 	lds	r18, 0x0211	; 0x800211 <CurPosition>
    156c:	90 e0       	ldi	r25, 0x00	; 0
    156e:	82 1b       	sub	r24, r18
    1570:	91 09       	sbc	r25, r1
    1572:	90 93 75 02 	sts	0x0275, r25	; 0x800275 <CurError+0x1>
    1576:	80 93 74 02 	sts	0x0274, r24	; 0x800274 <CurError>
    157a:	0f c0       	rjmp	.+30     	; 0x159a <stepUpdateError+0x88>
		}
	}else
	{
		CurError = Parts[countSort] - CurPosition;
    157c:	e0 91 64 02 	lds	r30, 0x0264	; 0x800264 <countSort>
    1580:	f0 e0       	ldi	r31, 0x00	; 0
    1582:	e7 58       	subi	r30, 0x87	; 135
    1584:	fd 4f       	sbci	r31, 0xFD	; 253
    1586:	80 81       	ld	r24, Z
    1588:	20 91 11 02 	lds	r18, 0x0211	; 0x800211 <CurPosition>
    158c:	90 e0       	ldi	r25, 0x00	; 0
    158e:	82 1b       	sub	r24, r18
    1590:	91 09       	sbc	r25, r1
    1592:	90 93 75 02 	sts	0x0275, r25	; 0x800275 <CurError+0x1>
    1596:	80 93 74 02 	sts	0x0274, r24	; 0x800274 <CurError>
	}
	
	
	if(CurError>100)
    159a:	80 91 74 02 	lds	r24, 0x0274	; 0x800274 <CurError>
    159e:	90 91 75 02 	lds	r25, 0x0275	; 0x800275 <CurError+0x1>
    15a2:	85 36       	cpi	r24, 0x65	; 101
    15a4:	91 05       	cpc	r25, r1
    15a6:	5c f0       	brlt	.+22     	; 0x15be <stepUpdateError+0xac>
	{
		CurError = CurError - 200;
    15a8:	80 91 74 02 	lds	r24, 0x0274	; 0x800274 <CurError>
    15ac:	90 91 75 02 	lds	r25, 0x0275	; 0x800275 <CurError+0x1>
    15b0:	88 5c       	subi	r24, 0xC8	; 200
    15b2:	91 09       	sbc	r25, r1
    15b4:	90 93 75 02 	sts	0x0275, r25	; 0x800275 <CurError+0x1>
    15b8:	80 93 74 02 	sts	0x0274, r24	; 0x800274 <CurError>
    15bc:	11 c0       	rjmp	.+34     	; 0x15e0 <stepUpdateError+0xce>
	}else if(CurError<-100)
    15be:	80 91 74 02 	lds	r24, 0x0274	; 0x800274 <CurError>
    15c2:	90 91 75 02 	lds	r25, 0x0275	; 0x800275 <CurError+0x1>
    15c6:	8c 39       	cpi	r24, 0x9C	; 156
    15c8:	9f 4f       	sbci	r25, 0xFF	; 255
    15ca:	54 f4       	brge	.+20     	; 0x15e0 <stepUpdateError+0xce>
	{
		CurError = CurError + 200;
    15cc:	80 91 74 02 	lds	r24, 0x0274	; 0x800274 <CurError>
    15d0:	90 91 75 02 	lds	r25, 0x0275	; 0x800275 <CurError+0x1>
    15d4:	88 53       	subi	r24, 0x38	; 56
    15d6:	9f 4f       	sbci	r25, 0xFF	; 255
    15d8:	90 93 75 02 	sts	0x0275, r25	; 0x800275 <CurError+0x1>
    15dc:	80 93 74 02 	sts	0x0274, r24	; 0x800274 <CurError>
	}
	
	if(abs(CurError) < Steps2Acc && !DROPFLAG)//change if slowing down to quickly at zone; may cause oscillation
    15e0:	20 91 74 02 	lds	r18, 0x0274	; 0x800274 <CurError>
    15e4:	30 91 75 02 	lds	r19, 0x0275	; 0x800275 <CurError+0x1>
    15e8:	33 23       	and	r19, r19
    15ea:	1c f4       	brge	.+6      	; 0x15f2 <stepUpdateError+0xe0>
    15ec:	31 95       	neg	r19
    15ee:	21 95       	neg	r18
    15f0:	31 09       	sbc	r19, r1
    15f2:	80 91 14 02 	lds	r24, 0x0214	; 0x800214 <Steps2Acc>
    15f6:	90 e0       	ldi	r25, 0x00	; 0
    15f8:	28 17       	cp	r18, r24
    15fa:	39 07       	cpc	r19, r25
    15fc:	44 f4       	brge	.+16     	; 0x160e <stepUpdateError+0xfc>
    15fe:	80 91 67 02 	lds	r24, 0x0267	; 0x800267 <DROPFLAG>
    1602:	81 11       	cpse	r24, r1
    1604:	04 c0       	rjmp	.+8      	; 0x160e <stepUpdateError+0xfc>
	{
		TARGETFLAG = 1;
    1606:	81 e0       	ldi	r24, 0x01	; 1
    1608:	80 93 6a 02 	sts	0x026A, r24	; 0x80026a <TARGETFLAG>
    160c:	02 c0       	rjmp	.+4      	; 0x1612 <stepUpdateError+0x100>
	}else
	{
		TARGETFLAG = 0;
    160e:	10 92 6a 02 	sts	0x026A, r1	; 0x80026a <TARGETFLAG>
	}
	return 1;
}
    1612:	81 e0       	ldi	r24, 0x01	; 1
    1614:	08 95       	ret

00001616 <stepUpdateDir>:
does not equal Dir, the stepper must be slowed to MAX delay before Dir is updated.
This is controlled by the DECELFLAG.
                                                               */
/************************************************************************/
uint8_t stepUpdateDir(void){
	if(CurError == 0)
    1616:	80 91 74 02 	lds	r24, 0x0274	; 0x800274 <CurError>
    161a:	90 91 75 02 	lds	r25, 0x0275	; 0x800275 <CurError+0x1>
    161e:	89 2b       	or	r24, r25
    1620:	91 f4       	brne	.+36     	; 0x1646 <stepUpdateDir+0x30>
	{// if stepper is at target
		if(CurDelay > (MAXDELAY-MINDELAY))
    1622:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <CurDelay>
    1626:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <CurDelay+0x1>
    162a:	81 31       	cpi	r24, 0x11	; 17
    162c:	97 40       	sbci	r25, 0x07	; 7
    162e:	30 f0       	brcs	.+12     	; 0x163c <stepUpdateDir+0x26>
		{// if stepper can stop
			Dir = 0; //stop stepping
    1630:	10 92 13 02 	sts	0x0213, r1	; 0x800213 <Dir>
			TARGETFLAG = 0; //clear target flag
    1634:	10 92 6a 02 	sts	0x026A, r1	; 0x80026a <TARGETFLAG>
			return 1;
    1638:	81 e0       	ldi	r24, 0x01	; 1
    163a:	08 95       	ret
		}else
		{//Decelerate stepper
			DECELFLAG = 1;
    163c:	81 e0       	ldi	r24, 0x01	; 1
    163e:	80 93 6d 02 	sts	0x026D, r24	; 0x80026d <DECELFLAG>
			return 0;
    1642:	80 e0       	ldi	r24, 0x00	; 0
    1644:	08 95       	ret
		}
	}else if((abs(CurError)>SPIN_ROUND_LIMIT) && (CurDelay<MAXDELAY))
    1646:	80 91 74 02 	lds	r24, 0x0274	; 0x800274 <CurError>
    164a:	90 91 75 02 	lds	r25, 0x0275	; 0x800275 <CurError+0x1>
    164e:	99 23       	and	r25, r25
    1650:	1c f4       	brge	.+6      	; 0x1658 <stepUpdateDir+0x42>
    1652:	91 95       	neg	r25
    1654:	81 95       	neg	r24
    1656:	91 09       	sbc	r25, r1
    1658:	8b 35       	cpi	r24, 0x5B	; 91
    165a:	91 05       	cpc	r25, r1
    165c:	b4 f0       	brlt	.+44     	; 0x168a <stepUpdateDir+0x74>
    165e:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <CurDelay>
    1662:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <CurDelay+0x1>
    1666:	81 15       	cp	r24, r1
    1668:	9a 40       	sbci	r25, 0x0A	; 10
    166a:	78 f4       	brcc	.+30     	; 0x168a <stepUpdateDir+0x74>
	{//Next target is close in same direction and at high speed
		DECELFLAG = 0;//Don't slow down
    166c:	10 92 6d 02 	sts	0x026D, r1	; 0x80026d <DECELFLAG>
		if(Dir != 0)
    1670:	80 91 13 02 	lds	r24, 0x0213	; 0x800213 <Dir>
    1674:	88 23       	and	r24, r24
    1676:	29 f0       	breq	.+10     	; 0x1682 <stepUpdateDir+0x6c>
		{//Keep direction
			NextDir = Dir;
    1678:	80 91 13 02 	lds	r24, 0x0213	; 0x800213 <Dir>
    167c:	80 93 12 02 	sts	0x0212, r24	; 0x800212 <NextDir>
			return 0;
		}
	}else if((abs(CurError)>SPIN_ROUND_LIMIT) && (CurDelay<MAXDELAY))
	{//Next target is close in same direction and at high speed
		DECELFLAG = 0;//Don't slow down
		if(Dir != 0)
    1680:	18 c0       	rjmp	.+48     	; 0x16b2 <stepUpdateDir+0x9c>
		{//Keep direction
			NextDir = Dir;
		}else
		{//edge case where Dir might be zero
			Dir = 1;
    1682:	81 e0       	ldi	r24, 0x01	; 1
    1684:	80 93 13 02 	sts	0x0213, r24	; 0x800213 <Dir>
			return 1;
    1688:	08 95       	ret
		}
	}else
	{//Calculate closest direction
		NextDir = (CurError>0) - (CurError<0);
    168a:	20 91 74 02 	lds	r18, 0x0274	; 0x800274 <CurError>
    168e:	30 91 75 02 	lds	r19, 0x0275	; 0x800275 <CurError+0x1>
    1692:	81 e0       	ldi	r24, 0x01	; 1
    1694:	12 16       	cp	r1, r18
    1696:	13 06       	cpc	r1, r19
    1698:	0c f0       	brlt	.+2      	; 0x169c <stepUpdateDir+0x86>
    169a:	80 e0       	ldi	r24, 0x00	; 0
    169c:	20 91 74 02 	lds	r18, 0x0274	; 0x800274 <CurError>
    16a0:	30 91 75 02 	lds	r19, 0x0275	; 0x800275 <CurError+0x1>
    16a4:	93 2f       	mov	r25, r19
    16a6:	99 1f       	adc	r25, r25
    16a8:	99 27       	eor	r25, r25
    16aa:	99 1f       	adc	r25, r25
    16ac:	89 1b       	sub	r24, r25
    16ae:	80 93 12 02 	sts	0x0212, r24	; 0x800212 <NextDir>
	}

	if(NextDir == Dir)
    16b2:	90 91 12 02 	lds	r25, 0x0212	; 0x800212 <NextDir>
    16b6:	80 91 13 02 	lds	r24, 0x0213	; 0x800213 <Dir>
    16ba:	98 13       	cpse	r25, r24
    16bc:	06 c0       	rjmp	.+12     	; 0x16ca <stepUpdateDir+0xb4>
	{//next direction is the same
		Dir = NextDir;
    16be:	80 91 12 02 	lds	r24, 0x0212	; 0x800212 <NextDir>
    16c2:	80 93 13 02 	sts	0x0213, r24	; 0x800213 <Dir>
		return 1;
    16c6:	81 e0       	ldi	r24, 0x01	; 1
    16c8:	08 95       	ret
	}else if(CurDelay >= MAXDELAY)
    16ca:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <CurDelay>
    16ce:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <CurDelay+0x1>
    16d2:	81 15       	cp	r24, r1
    16d4:	9a 40       	sbci	r25, 0x0A	; 10
    16d6:	30 f0       	brcs	.+12     	; 0x16e4 <stepUpdateDir+0xce>
	{//stepper is can change direction
		Dir = NextDir;
    16d8:	80 91 12 02 	lds	r24, 0x0212	; 0x800212 <NextDir>
    16dc:	80 93 13 02 	sts	0x0213, r24	; 0x800213 <Dir>
		return 1;
    16e0:	81 e0       	ldi	r24, 0x01	; 1
    16e2:	08 95       	ret
	}else
	{//Decelerate stepper to switch directions
		DECELFLAG = 1;
    16e4:	81 e0       	ldi	r24, 0x01	; 1
    16e6:	80 93 6d 02 	sts	0x026D, r24	; 0x80026d <DECELFLAG>
		return 0;
    16ea:	80 e0       	ldi	r24, 0x00	; 0
	}
	return 1;
}
    16ec:	08 95       	ret

000016ee <stepRes>:
}


//Resets stepper parameters when the stepper is stopped
void stepRes(void){
	accSteps = 0;
    16ee:	10 92 78 02 	sts	0x0278, r1	; 0x800278 <accSteps>
	StepsDelta = 0;
    16f2:	10 92 72 02 	sts	0x0272, r1	; 0x800272 <StepsDelta>
	CurDelay = MAXDELAY;
    16f6:	80 e0       	ldi	r24, 0x00	; 0
    16f8:	9a e0       	ldi	r25, 0x0A	; 10
    16fa:	90 93 77 02 	sts	0x0277, r25	; 0x800277 <CurDelay+0x1>
    16fe:	80 93 76 02 	sts	0x0276, r24	; 0x800276 <CurDelay>
    1702:	08 95       	ret

00001704 <stepUpdateDelay>:
                                                               */
/************************************************************************/
uint8_t stepUpdateDelay(void)
{
	
	if(Dir==0)
    1704:	80 91 13 02 	lds	r24, 0x0213	; 0x800213 <Dir>
    1708:	81 11       	cpse	r24, r1
    170a:	02 c0       	rjmp	.+4      	; 0x1710 <stepUpdateDelay+0xc>
	{//if stepper is not stepping:
		stepRes();//reset stepper
    170c:	f0 df       	rcall	.-32     	; 0x16ee <stepRes>
    170e:	75 c0       	rjmp	.+234    	; 0x17fa <stepUpdateDelay+0xf6>
	}else if(TARGETFLAG || DECELFLAG || PAUSEFLAG)
    1710:	80 91 6a 02 	lds	r24, 0x026A	; 0x80026a <TARGETFLAG>
    1714:	81 11       	cpse	r24, r1
    1716:	08 c0       	rjmp	.+16     	; 0x1728 <stepUpdateDelay+0x24>
    1718:	80 91 6d 02 	lds	r24, 0x026D	; 0x80026d <DECELFLAG>
    171c:	81 11       	cpse	r24, r1
    171e:	04 c0       	rjmp	.+8      	; 0x1728 <stepUpdateDelay+0x24>
    1720:	80 91 69 02 	lds	r24, 0x0269	; 0x800269 <PAUSEFLAG>
    1724:	88 23       	and	r24, r24
    1726:	81 f1       	breq	.+96     	; 0x1788 <stepUpdateDelay+0x84>
	{//Decelerate if prompted
		CurDelay = CurDelay + CurAcc[accSteps];
    1728:	e0 91 78 02 	lds	r30, 0x0278	; 0x800278 <accSteps>
    172c:	f0 e0       	ldi	r31, 0x00	; 0
    172e:	ee 0f       	add	r30, r30
    1730:	ff 1f       	adc	r31, r31
    1732:	e2 52       	subi	r30, 0x22	; 34
    1734:	fd 4f       	sbci	r31, 0xFD	; 253
    1736:	20 81       	ld	r18, Z
    1738:	31 81       	ldd	r19, Z+1	; 0x01
    173a:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <CurDelay>
    173e:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <CurDelay+0x1>
    1742:	82 0f       	add	r24, r18
    1744:	93 1f       	adc	r25, r19
    1746:	90 93 77 02 	sts	0x0277, r25	; 0x800277 <CurDelay+0x1>
    174a:	80 93 76 02 	sts	0x0276, r24	; 0x800276 <CurDelay>
		if (CurDelay > MAXDELAY)
    174e:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <CurDelay>
    1752:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <CurDelay+0x1>
    1756:	81 30       	cpi	r24, 0x01	; 1
    1758:	9a 40       	sbci	r25, 0x0A	; 10
    175a:	58 f0       	brcs	.+22     	; 0x1772 <stepUpdateDelay+0x6e>
		{
			accSteps = 0;
    175c:	10 92 78 02 	sts	0x0278, r1	; 0x800278 <accSteps>
			CurDelay = MAXDELAY;
    1760:	80 e0       	ldi	r24, 0x00	; 0
    1762:	9a e0       	ldi	r25, 0x0A	; 10
    1764:	90 93 77 02 	sts	0x0277, r25	; 0x800277 <CurDelay+0x1>
    1768:	80 93 76 02 	sts	0x0276, r24	; 0x800276 <CurDelay>
			DECELFLAG = 0;
    176c:	10 92 6d 02 	sts	0x026D, r1	; 0x80026d <DECELFLAG>
    1770:	44 c0       	rjmp	.+136    	; 0x17fa <stepUpdateDelay+0xf6>
		
		}else if(accSteps>0)
    1772:	80 91 78 02 	lds	r24, 0x0278	; 0x800278 <accSteps>
    1776:	88 23       	and	r24, r24
    1778:	09 f4       	brne	.+2      	; 0x177c <stepUpdateDelay+0x78>
    177a:	3f c0       	rjmp	.+126    	; 0x17fa <stepUpdateDelay+0xf6>
		{
			accSteps--;
    177c:	80 91 78 02 	lds	r24, 0x0278	; 0x800278 <accSteps>
    1780:	81 50       	subi	r24, 0x01	; 1
    1782:	80 93 78 02 	sts	0x0278, r24	; 0x800278 <accSteps>
    1786:	39 c0       	rjmp	.+114    	; 0x17fa <stepUpdateDelay+0xf6>
		}
		
	}else if(CurDelay>MINDELAY)
    1788:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <CurDelay>
    178c:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <CurDelay+0x1>
    1790:	81 3f       	cpi	r24, 0xF1	; 241
    1792:	92 40       	sbci	r25, 0x02	; 2
    1794:	e0 f1       	brcs	.+120    	; 0x180e <stepUpdateDelay+0x10a>
	{//Accelerate if able
		CurDelay = CurDelay -  CurAcc[accSteps];
    1796:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <CurDelay>
    179a:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <CurDelay+0x1>
    179e:	e0 91 78 02 	lds	r30, 0x0278	; 0x800278 <accSteps>
    17a2:	f0 e0       	ldi	r31, 0x00	; 0
    17a4:	ee 0f       	add	r30, r30
    17a6:	ff 1f       	adc	r31, r31
    17a8:	e2 52       	subi	r30, 0x22	; 34
    17aa:	fd 4f       	sbci	r31, 0xFD	; 253
    17ac:	20 81       	ld	r18, Z
    17ae:	31 81       	ldd	r19, Z+1	; 0x01
    17b0:	82 1b       	sub	r24, r18
    17b2:	93 0b       	sbc	r25, r19
    17b4:	90 93 77 02 	sts	0x0277, r25	; 0x800277 <CurDelay+0x1>
    17b8:	80 93 76 02 	sts	0x0276, r24	; 0x800276 <CurDelay>
		if (CurDelay <= MINDELAY || CurDelay > MAXDELAY)
    17bc:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <CurDelay>
    17c0:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <CurDelay+0x1>
    17c4:	81 3f       	cpi	r24, 0xF1	; 241
    17c6:	92 40       	sbci	r25, 0x02	; 2
    17c8:	38 f0       	brcs	.+14     	; 0x17d8 <stepUpdateDelay+0xd4>
    17ca:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <CurDelay>
    17ce:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <CurDelay+0x1>
    17d2:	81 30       	cpi	r24, 0x01	; 1
    17d4:	9a 40       	sbci	r25, 0x0A	; 10
    17d6:	30 f0       	brcs	.+12     	; 0x17e4 <stepUpdateDelay+0xe0>
		{//overflow protection
			CurDelay = MINDELAY;
    17d8:	80 ef       	ldi	r24, 0xF0	; 240
    17da:	92 e0       	ldi	r25, 0x02	; 2
    17dc:	90 93 77 02 	sts	0x0277, r25	; 0x800277 <CurDelay+0x1>
    17e0:	80 93 76 02 	sts	0x0276, r24	; 0x800276 <CurDelay>
		}
		if(accSteps<Steps2Acc)
    17e4:	90 91 78 02 	lds	r25, 0x0278	; 0x800278 <accSteps>
    17e8:	80 91 14 02 	lds	r24, 0x0214	; 0x800214 <Steps2Acc>
    17ec:	98 17       	cp	r25, r24
    17ee:	28 f4       	brcc	.+10     	; 0x17fa <stepUpdateDelay+0xf6>
		{//acceleration increase
			accSteps++;
    17f0:	80 91 78 02 	lds	r24, 0x0278	; 0x800278 <accSteps>
    17f4:	8f 5f       	subi	r24, 0xFF	; 255
    17f6:	80 93 78 02 	sts	0x0278, r24	; 0x800278 <accSteps>
	}else
	{
		return 0;
	}
	
	OCR3A = CurDelay;//set the new delay
    17fa:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <CurDelay>
    17fe:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <CurDelay+0x1>
    1802:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x7c0099>
    1806:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x7c0098>
	return 1;
    180a:	81 e0       	ldi	r24, 0x01	; 1
    180c:	08 95       	ret
		{//acceleration increase
			accSteps++;
		}
	}else
	{
		return 0;
    180e:	80 e0       	ldi	r24, 0x00	; 0
	}
	
	OCR3A = CurDelay;//set the new delay
	return 1;
}
    1810:	08 95       	ret

00001812 <stepTimer_init>:


//Initializes the hardware timer used to control the stepper
void stepTimer_init (void)
{
	TCCR3B |= _BV(WGM32);//Set CTC mode
    1812:	e1 e9       	ldi	r30, 0x91	; 145
    1814:	f0 e0       	ldi	r31, 0x00	; 0
    1816:	80 81       	ld	r24, Z
    1818:	88 60       	ori	r24, 0x08	; 8
    181a:	80 83       	st	Z, r24
	OCR3A = 0xFFFF; //Clear compare register A
    181c:	8f ef       	ldi	r24, 0xFF	; 255
    181e:	9f ef       	ldi	r25, 0xFF	; 255
    1820:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x7c0099>
    1824:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x7c0098>
	TCNT3 = 0x0000; //Clear count register
    1828:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x7c0095>
    182c:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x7c0094>
	TIMSK3 |= _BV(OCIE3A);  //Enable Interrupt
    1830:	e1 e7       	ldi	r30, 0x71	; 113
    1832:	f0 e0       	ldi	r31, 0x00	; 0
    1834:	80 81       	ld	r24, Z
    1836:	82 60       	ori	r24, 0x02	; 2
    1838:	80 83       	st	Z, r24
    183a:	08 95       	ret

0000183c <stepStart>:
	return;
} //stepTimer_init

//enable the stepper timer and reset the stepper.
void stepStart(void){
	TCNT3 = 0x0000;//Reset counter
    183c:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x7c0095>
    1840:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x7c0094>
	OCR3A = MAXDELAY;//Set compare value
    1844:	20 e0       	ldi	r18, 0x00	; 0
    1846:	3a e0       	ldi	r19, 0x0A	; 10
    1848:	30 93 99 00 	sts	0x0099, r19	; 0x800099 <__TEXT_REGION_LENGTH__+0x7c0099>
    184c:	20 93 98 00 	sts	0x0098, r18	; 0x800098 <__TEXT_REGION_LENGTH__+0x7c0098>
	TCCR3B |= _BV(CS31) | _BV(CS30);//Enable Stepper with prescaler
    1850:	e1 e9       	ldi	r30, 0x91	; 145
    1852:	f0 e0       	ldi	r31, 0x00	; 0
    1854:	80 81       	ld	r24, Z
    1856:	83 60       	ori	r24, 0x03	; 3
    1858:	80 83       	st	Z, r24
	TIFR3 |= _BV(OCF3A);//Reset interrupt flag
    185a:	88 b3       	in	r24, 0x18	; 24
    185c:	82 60       	ori	r24, 0x02	; 2
    185e:	88 bb       	out	0x18, r24	; 24
	CurDelay = MAXDELAY;//Reset CurDelay
    1860:	30 93 77 02 	sts	0x0277, r19	; 0x800277 <CurDelay+0x1>
    1864:	20 93 76 02 	sts	0x0276, r18	; 0x800276 <CurDelay>
    1868:	08 95       	ret

0000186a <stepStop>:
}//stepStart

//stop the stepper timer
void stepStop(void){
	TCCR3B &= ~_BV(CS31);//Disable timer
    186a:	e1 e9       	ldi	r30, 0x91	; 145
    186c:	f0 e0       	ldi	r31, 0x00	; 0
    186e:	80 81       	ld	r24, Z
    1870:	8d 7f       	andi	r24, 0xFD	; 253
    1872:	80 83       	st	Z, r24
	TCCR3B &=~_BV(CS30);
    1874:	80 81       	ld	r24, Z
    1876:	8e 7f       	andi	r24, 0xFE	; 254
    1878:	80 83       	st	Z, r24
    187a:	08 95       	ret

0000187c <stepCalcAcc>:
	uint16_t JERK = MAXACC/JERKSTEPS;
	uint16_t steps = 0;
	uint16_t delay = MAXDELAY;

	//FIRST STAGE: positive jerk
	CurAcc[steps] = 0;
    187c:	10 92 df 02 	sts	0x02DF, r1	; 0x8002df <CurAcc+0x1>
    1880:	10 92 de 02 	sts	0x02DE, r1	; 0x8002de <CurAcc>
/************************************************************************/
void stepCalcAcc(void){

	uint16_t JERK = MAXACC/JERKSTEPS;
	uint16_t steps = 0;
	uint16_t delay = MAXDELAY;
    1884:	20 e0       	ldi	r18, 0x00	; 0
    1886:	3a e0       	ldi	r19, 0x0A	; 10

	//FIRST STAGE: positive jerk
	CurAcc[steps] = 0;
	for(steps = 1; steps<JERKSTEPS; steps++)
    1888:	81 e0       	ldi	r24, 0x01	; 1
    188a:	90 e0       	ldi	r25, 0x00	; 0
    188c:	24 c0       	rjmp	.+72     	; 0x18d6 <stepCalcAcc+0x5a>
	{
		delay -=CurAcc[steps-1];
    188e:	fc 01       	movw	r30, r24
    1890:	31 97       	sbiw	r30, 0x01	; 1
    1892:	ee 0f       	add	r30, r30
    1894:	ff 1f       	adc	r31, r31
    1896:	e2 52       	subi	r30, 0x22	; 34
    1898:	fd 4f       	sbci	r31, 0xFD	; 253
    189a:	40 81       	ld	r20, Z
    189c:	51 81       	ldd	r21, Z+1	; 0x01
    189e:	24 1b       	sub	r18, r20
    18a0:	35 0b       	sbc	r19, r21
		CurAcc[steps] = CurAcc[steps-1]+JERK;
    18a2:	40 81       	ld	r20, Z
    18a4:	51 81       	ldd	r21, Z+1	; 0x01
    18a6:	44 5c       	subi	r20, 0xC4	; 196
    18a8:	5f 4f       	sbci	r21, 0xFF	; 255
    18aa:	fc 01       	movw	r30, r24
    18ac:	ee 0f       	add	r30, r30
    18ae:	ff 1f       	adc	r31, r31
    18b0:	e2 52       	subi	r30, 0x22	; 34
    18b2:	fd 4f       	sbci	r31, 0xFD	; 253
    18b4:	51 83       	std	Z+1, r21	; 0x01
    18b6:	40 83       	st	Z, r20
		if(CurAcc[steps]>MAXACC){
    18b8:	40 81       	ld	r20, Z
    18ba:	51 81       	ldd	r21, Z+1	; 0x01
    18bc:	41 3f       	cpi	r20, 0xF1	; 241
    18be:	51 05       	cpc	r21, r1
    18c0:	48 f0       	brcs	.+18     	; 0x18d4 <stepCalcAcc+0x58>
			CurAcc[steps] = MAXACC;
    18c2:	fc 01       	movw	r30, r24
    18c4:	ee 0f       	add	r30, r30
    18c6:	ff 1f       	adc	r31, r31
    18c8:	e2 52       	subi	r30, 0x22	; 34
    18ca:	fd 4f       	sbci	r31, 0xFD	; 253
    18cc:	40 ef       	ldi	r20, 0xF0	; 240
    18ce:	50 e0       	ldi	r21, 0x00	; 0
    18d0:	51 83       	std	Z+1, r21	; 0x01
    18d2:	40 83       	st	Z, r20
	uint16_t steps = 0;
	uint16_t delay = MAXDELAY;

	//FIRST STAGE: positive jerk
	CurAcc[steps] = 0;
	for(steps = 1; steps<JERKSTEPS; steps++)
    18d4:	01 96       	adiw	r24, 0x01	; 1
    18d6:	84 30       	cpi	r24, 0x04	; 4
    18d8:	91 05       	cpc	r25, r1
    18da:	c8 f2       	brcs	.-78     	; 0x188e <stepCalcAcc+0x12>
		}
	}//Increase Acceleration
	
	
	//Second Stage: Constant Acceleration
	CurAcc[steps] = MAXACC;
    18dc:	fc 01       	movw	r30, r24
    18de:	ee 0f       	add	r30, r30
    18e0:	ff 1f       	adc	r31, r31
    18e2:	e2 52       	subi	r30, 0x22	; 34
    18e4:	fd 4f       	sbci	r31, 0xFD	; 253
    18e6:	40 ef       	ldi	r20, 0xF0	; 240
    18e8:	50 e0       	ldi	r21, 0x00	; 0
    18ea:	51 83       	std	Z+1, r21	; 0x01
    18ec:	40 83       	st	Z, r20
	while((delay -MAXACC -JERK*JERKSTEPS*JERKSTEPS/2)>MINDELAY){
    18ee:	1a c0       	rjmp	.+52     	; 0x1924 <stepCalcAcc+0xa8>
		delay -=CurAcc[steps-1];
    18f0:	fc 01       	movw	r30, r24
    18f2:	31 97       	sbiw	r30, 0x01	; 1
    18f4:	ee 0f       	add	r30, r30
    18f6:	ff 1f       	adc	r31, r31
    18f8:	e2 52       	subi	r30, 0x22	; 34
    18fa:	fd 4f       	sbci	r31, 0xFD	; 253
    18fc:	40 81       	ld	r20, Z
    18fe:	51 81       	ldd	r21, Z+1	; 0x01
    1900:	24 1b       	sub	r18, r20
    1902:	35 0b       	sbc	r19, r21
		if(delay<MINDELAY){
    1904:	20 3f       	cpi	r18, 0xF0	; 240
    1906:	42 e0       	ldi	r20, 0x02	; 2
    1908:	34 07       	cpc	r19, r20
    190a:	10 f4       	brcc	.+4      	; 0x1910 <stepCalcAcc+0x94>
			delay = MINDELAY;
    190c:	20 ef       	ldi	r18, 0xF0	; 240
    190e:	32 e0       	ldi	r19, 0x02	; 2
		}
		steps++;
    1910:	01 96       	adiw	r24, 0x01	; 1
		CurAcc[steps] = MAXACC;
    1912:	fc 01       	movw	r30, r24
    1914:	ee 0f       	add	r30, r30
    1916:	ff 1f       	adc	r31, r31
    1918:	e2 52       	subi	r30, 0x22	; 34
    191a:	fd 4f       	sbci	r31, 0xFD	; 253
    191c:	40 ef       	ldi	r20, 0xF0	; 240
    191e:	50 e0       	ldi	r21, 0x00	; 0
    1920:	51 83       	std	Z+1, r21	; 0x01
    1922:	40 83       	st	Z, r20
	}//Increase Acceleration
	
	
	//Second Stage: Constant Acceleration
	CurAcc[steps] = MAXACC;
	while((delay -MAXACC -JERK*JERKSTEPS*JERKSTEPS/2)>MINDELAY){
    1924:	a9 01       	movw	r20, r18
    1926:	40 5d       	subi	r20, 0xD0	; 208
    1928:	52 40       	sbci	r21, 0x02	; 2
    192a:	41 3f       	cpi	r20, 0xF1	; 241
    192c:	52 40       	sbci	r21, 0x02	; 2
    192e:	00 f7       	brcc	.-64     	; 0x18f0 <stepCalcAcc+0x74>
    1930:	2a c0       	rjmp	.+84     	; 0x1986 <stepCalcAcc+0x10a>
		CurAcc[steps] = MAXACC;
	}//Constant Acceleration
	
	//Third Stage: Negative jerk to Max Speed -> MINDELAY
	while(delay >MINDELAY){
		steps++;
    1932:	ac 01       	movw	r20, r24
    1934:	4f 5f       	subi	r20, 0xFF	; 255
    1936:	5f 4f       	sbci	r21, 0xFF	; 255
		
		delay -=CurAcc[steps-1];
    1938:	fc 01       	movw	r30, r24
    193a:	ee 0f       	add	r30, r30
    193c:	ff 1f       	adc	r31, r31
    193e:	e2 52       	subi	r30, 0x22	; 34
    1940:	fd 4f       	sbci	r31, 0xFD	; 253
    1942:	60 81       	ld	r22, Z
    1944:	71 81       	ldd	r23, Z+1	; 0x01
    1946:	26 1b       	sub	r18, r22
    1948:	37 0b       	sbc	r19, r23
		if(JERK> CurAcc[steps-1])
    194a:	60 81       	ld	r22, Z
    194c:	71 81       	ldd	r23, Z+1	; 0x01
    194e:	6c 33       	cpi	r22, 0x3C	; 60
    1950:	71 05       	cpc	r23, r1
    1952:	48 f4       	brcc	.+18     	; 0x1966 <stepCalcAcc+0xea>
		{
			CurAcc[steps] = 0;
    1954:	fa 01       	movw	r30, r20
    1956:	ee 0f       	add	r30, r30
    1958:	ff 1f       	adc	r31, r31
    195a:	e2 52       	subi	r30, 0x22	; 34
    195c:	fd 4f       	sbci	r31, 0xFD	; 253
    195e:	11 82       	std	Z+1, r1	; 0x01
    1960:	10 82       	st	Z, r1
		CurAcc[steps] = MAXACC;
	}//Constant Acceleration
	
	//Third Stage: Negative jerk to Max Speed -> MINDELAY
	while(delay >MINDELAY){
		steps++;
    1962:	ca 01       	movw	r24, r20
		
		delay -=CurAcc[steps-1];
		if(JERK> CurAcc[steps-1])
		{
			CurAcc[steps] = 0;
			break;
    1964:	14 c0       	rjmp	.+40     	; 0x198e <stepCalcAcc+0x112>
		}else	
		{
			CurAcc[steps] = CurAcc[steps-1]-JERK;	
    1966:	88 0f       	add	r24, r24
    1968:	99 1f       	adc	r25, r25
    196a:	fc 01       	movw	r30, r24
    196c:	e2 52       	subi	r30, 0x22	; 34
    196e:	fd 4f       	sbci	r31, 0xFD	; 253
    1970:	80 81       	ld	r24, Z
    1972:	91 81       	ldd	r25, Z+1	; 0x01
    1974:	cc 97       	sbiw	r24, 0x3c	; 60
    1976:	fa 01       	movw	r30, r20
    1978:	ee 0f       	add	r30, r30
    197a:	ff 1f       	adc	r31, r31
    197c:	e2 52       	subi	r30, 0x22	; 34
    197e:	fd 4f       	sbci	r31, 0xFD	; 253
    1980:	91 83       	std	Z+1, r25	; 0x01
    1982:	80 83       	st	Z, r24
		CurAcc[steps] = MAXACC;
	}//Constant Acceleration
	
	//Third Stage: Negative jerk to Max Speed -> MINDELAY
	while(delay >MINDELAY){
		steps++;
    1984:	ca 01       	movw	r24, r20
		steps++;
		CurAcc[steps] = MAXACC;
	}//Constant Acceleration
	
	//Third Stage: Negative jerk to Max Speed -> MINDELAY
	while(delay >MINDELAY){
    1986:	21 3f       	cpi	r18, 0xF1	; 241
    1988:	42 e0       	ldi	r20, 0x02	; 2
    198a:	34 07       	cpc	r19, r20
    198c:	90 f6       	brcc	.-92     	; 0x1932 <stepCalcAcc+0xb6>
		}

	}//Decrease Acceleration
	
	//Record how many steps it take to reach maximum speed from rest
	Steps2Acc = steps;
    198e:	80 93 14 02 	sts	0x0214, r24	; 0x800214 <Steps2Acc>
    1992:	08 95       	ret

00001994 <stepCalibrate>:
                                                               */
/************************************************************************/
int8_t stepCalibrate(void){
	
	//Calculate the acceleration profile
	stepCalcAcc();
    1994:	73 df       	rcall	.-282    	; 0x187c <stepCalcAcc>
	
	//set stepper to slowest speed
	CurDelay = MAXDELAY;
    1996:	80 e0       	ldi	r24, 0x00	; 0
    1998:	9a e0       	ldi	r25, 0x0A	; 10
    199a:	90 93 77 02 	sts	0x0277, r25	; 0x800277 <CurDelay+0x1>
    199e:	80 93 76 02 	sts	0x0276, r24	; 0x800276 <CurDelay>
	CurPosition = 0;//set CurPosition
    19a2:	10 92 11 02 	sts	0x0211, r1	; 0x800211 <CurPosition>
	
	//move 50 steps to align poles and steps
	Parts[0] = 50;//Set stepper to move 50 steps
    19a6:	82 e3       	ldi	r24, 0x32	; 50
    19a8:	80 93 79 02 	sts	0x0279, r24	; 0x800279 <Parts>
	stepStart();//Start stepper
    19ac:	47 df       	rcall	.-370    	; 0x183c <stepStart>
	while(CurError !=0)
    19ae:	03 c0       	rjmp	.+6      	; 0x19b6 <stepCalibrate+0x22>
	{
		//prevent stepper from accelerating
		DECELFLAG = 1;
    19b0:	81 e0       	ldi	r24, 0x01	; 1
    19b2:	80 93 6d 02 	sts	0x026D, r24	; 0x80026d <DECELFLAG>
	CurPosition = 0;//set CurPosition
	
	//move 50 steps to align poles and steps
	Parts[0] = 50;//Set stepper to move 50 steps
	stepStart();//Start stepper
	while(CurError !=0)
    19b6:	80 91 74 02 	lds	r24, 0x0274	; 0x800274 <CurError>
    19ba:	90 91 75 02 	lds	r25, 0x0275	; 0x800275 <CurError+0x1>
    19be:	89 2b       	or	r24, r25
    19c0:	b9 f7       	brne	.-18     	; 0x19b0 <stepCalibrate+0x1c>
		//prevent stepper from accelerating
		DECELFLAG = 1;
	}
	
	//move until HE triggers ISR(INT3_vect)
	HALLSENSOR = 0;
    19c2:	10 92 71 02 	sts	0x0271, r1	; 0x800271 <HALLSENSOR>
	CurPosition = 0;
    19c6:	10 92 11 02 	sts	0x0211, r1	; 0x800211 <CurPosition>
	while(!HALLSENSOR)
    19ca:	11 c0       	rjmp	.+34     	; 0x19ee <stepCalibrate+0x5a>
	{
		//keep stepper moving forwards
		if(abs(CurError)<30 && !HALLSENSOR){
    19cc:	80 91 74 02 	lds	r24, 0x0274	; 0x800274 <CurError>
    19d0:	90 91 75 02 	lds	r25, 0x0275	; 0x800275 <CurError+0x1>
    19d4:	99 23       	and	r25, r25
    19d6:	1c f4       	brge	.+6      	; 0x19de <stepCalibrate+0x4a>
    19d8:	91 95       	neg	r25
    19da:	81 95       	neg	r24
    19dc:	91 09       	sbc	r25, r1
    19de:	4e 97       	sbiw	r24, 0x1e	; 30
    19e0:	34 f4       	brge	.+12     	; 0x19ee <stepCalibrate+0x5a>
    19e2:	80 91 71 02 	lds	r24, 0x0271	; 0x800271 <HALLSENSOR>
    19e6:	81 11       	cpse	r24, r1
    19e8:	02 c0       	rjmp	.+4      	; 0x19ee <stepCalibrate+0x5a>
			CurPosition = 0;
    19ea:	10 92 11 02 	sts	0x0211, r1	; 0x800211 <CurPosition>
	}
	
	//move until HE triggers ISR(INT3_vect)
	HALLSENSOR = 0;
	CurPosition = 0;
	while(!HALLSENSOR)
    19ee:	80 91 71 02 	lds	r24, 0x0271	; 0x800271 <HALLSENSOR>
    19f2:	88 23       	and	r24, r24
    19f4:	59 f3       	breq	.-42     	; 0x19cc <stepCalibrate+0x38>
			CurPosition = 0;
		}
	}//Wait for hall sensor to trigger
	
	//move stepper to face black region
	Parts[0] = B_ID;
    19f6:	82 e3       	ldi	r24, 0x32	; 50
    19f8:	80 93 79 02 	sts	0x0279, r24	; 0x800279 <Parts>
	return 1;
}
    19fc:	81 e0       	ldi	r24, 0x01	; 1
    19fe:	08 95       	ret

00001a00 <__divmodhi4>:
    1a00:	97 fb       	bst	r25, 7
    1a02:	07 2e       	mov	r0, r23
    1a04:	16 f4       	brtc	.+4      	; 0x1a0a <__divmodhi4+0xa>
    1a06:	00 94       	com	r0
    1a08:	06 d0       	rcall	.+12     	; 0x1a16 <__divmodhi4_neg1>
    1a0a:	77 fd       	sbrc	r23, 7
    1a0c:	08 d0       	rcall	.+16     	; 0x1a1e <__divmodhi4_neg2>
    1a0e:	1a d0       	rcall	.+52     	; 0x1a44 <__udivmodhi4>
    1a10:	07 fc       	sbrc	r0, 7
    1a12:	05 d0       	rcall	.+10     	; 0x1a1e <__divmodhi4_neg2>
    1a14:	3e f4       	brtc	.+14     	; 0x1a24 <__divmodhi4_exit>

00001a16 <__divmodhi4_neg1>:
    1a16:	90 95       	com	r25
    1a18:	81 95       	neg	r24
    1a1a:	9f 4f       	sbci	r25, 0xFF	; 255
    1a1c:	08 95       	ret

00001a1e <__divmodhi4_neg2>:
    1a1e:	70 95       	com	r23
    1a20:	61 95       	neg	r22
    1a22:	7f 4f       	sbci	r23, 0xFF	; 255

00001a24 <__divmodhi4_exit>:
    1a24:	08 95       	ret

00001a26 <__umulhisi3>:
    1a26:	a2 9f       	mul	r26, r18
    1a28:	b0 01       	movw	r22, r0
    1a2a:	b3 9f       	mul	r27, r19
    1a2c:	c0 01       	movw	r24, r0
    1a2e:	a3 9f       	mul	r26, r19
    1a30:	70 0d       	add	r23, r0
    1a32:	81 1d       	adc	r24, r1
    1a34:	11 24       	eor	r1, r1
    1a36:	91 1d       	adc	r25, r1
    1a38:	b2 9f       	mul	r27, r18
    1a3a:	70 0d       	add	r23, r0
    1a3c:	81 1d       	adc	r24, r1
    1a3e:	11 24       	eor	r1, r1
    1a40:	91 1d       	adc	r25, r1
    1a42:	08 95       	ret

00001a44 <__udivmodhi4>:
    1a44:	aa 1b       	sub	r26, r26
    1a46:	bb 1b       	sub	r27, r27
    1a48:	51 e1       	ldi	r21, 0x11	; 17
    1a4a:	07 c0       	rjmp	.+14     	; 0x1a5a <__udivmodhi4_ep>

00001a4c <__udivmodhi4_loop>:
    1a4c:	aa 1f       	adc	r26, r26
    1a4e:	bb 1f       	adc	r27, r27
    1a50:	a6 17       	cp	r26, r22
    1a52:	b7 07       	cpc	r27, r23
    1a54:	10 f0       	brcs	.+4      	; 0x1a5a <__udivmodhi4_ep>
    1a56:	a6 1b       	sub	r26, r22
    1a58:	b7 0b       	sbc	r27, r23

00001a5a <__udivmodhi4_ep>:
    1a5a:	88 1f       	adc	r24, r24
    1a5c:	99 1f       	adc	r25, r25
    1a5e:	5a 95       	dec	r21
    1a60:	a9 f7       	brne	.-22     	; 0x1a4c <__udivmodhi4_loop>
    1a62:	80 95       	com	r24
    1a64:	90 95       	com	r25
    1a66:	bc 01       	movw	r22, r24
    1a68:	cd 01       	movw	r24, r26
    1a6a:	08 95       	ret

00001a6c <_exit>:
    1a6c:	f8 94       	cli

00001a6e <__stop_program>:
    1a6e:	ff cf       	rjmp	.-2      	; 0x1a6e <__stop_program>
